{"version":3,"file":"index-DalesL42.js","sources":["../../../react/lib/jupyter/lite/server/service-manager.js","../../../react/lib/jupyter/lite/contents/contents.js","../../../react/lib/jupyter/lite/contents/broadcast.js","../../../../node_modules/async-mutex/index.mjs","../../../react/lib/jupyter/lite/kernel/kernels.js","../../../react/lib/jupyter/lite/kernel/kernelspecs.js","../../../react/lib/jupyter/lite/localforage/tokens.js","../../../../node_modules/localforage-memoryStorageDriver/dist/localforage-memoryStorageDriver.es6.js","../../../react/lib/jupyter/lite/session/tokens.js","../../../react/lib/jupyter/lite/session/sessions.js","../../../react/lib/jupyter/lite/licenses/tokens.js","../../../react/lib/jupyter/lite/licenses/licenses.js","../../../react/lib/jupyter/lite/settings/settings.js","../../../react/lib/jupyter/lite/settings/tokens.js","../../../react/lib/jupyter/lite/translation/translation.js","../../../react/lib/jupyter/lite/translation/tokens.js","../../../../node_modules/localforage/dist/localforage.js","../../../react/lib/jupyter/lite/server-extension/index.js","../../../react/lib/jupyter/lite/localforage/memory.js"],"sourcesContent":["/*\n * Copyright (c) 2021-2023 Datalayer, Inc.\n *\n * MIT License\n */\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport { PageConfig, URLExt } from '@jupyterlab/coreutils';\nconst VERSION = PageConfig.getOption('appVersion');\nconst SW_PING_ENDPOINT = '/api/service-worker-heartbeat';\nexport class ServiceWorkerManager {\n    constructor(options) {\n        /*\n        const workerUrl =\n          options?.workerUrl ?? URLExt.join(PageConfig.getBaseUrl(), WORKER_NAME);\n        const fullWorkerUrl = new URL(workerUrl, window.location.href);\n        const enableCache = PageConfig.getOption('enableServiceWorkerCache') || 'false';\n        fullWorkerUrl.searchParams.set('enableCache', enableCache);\n        void this.initialize(fullWorkerUrl.href).catch(console.warn);\n        */\n        const workerUrl = URLExt.join(PageConfig.getOption('serviceWorkerUrl'));\n        const fullWorkerUrl = new URL(workerUrl);\n        fullWorkerUrl.searchParams.set('enableCache', 'true');\n        void this.initialize(fullWorkerUrl.href).catch(console.warn);\n    }\n    /**\n     * A signal emitted when the registration changes.\n     */\n    get registrationChanged() {\n        return this._registrationChanged;\n    }\n    /**\n     * Whether the ServiceWorker is enabled or not.\n     */\n    get enabled() {\n        return this._registration !== null;\n    }\n    get ready() {\n        return this._ready.promise;\n    }\n    unregisterOldServiceWorkers = async (scriptURL) => {\n        const versionKey = `${scriptURL}-version`;\n        // Check if we have an installed version. If we do, compare it to the current version\n        // and unregister all service workers if they are different.\n        const installedVersion = localStorage.getItem(versionKey);\n        if ((installedVersion && installedVersion !== VERSION) ||\n            !installedVersion) {\n            // eslint-disable-next-line no-console\n            console.info('New version, unregistering existing service workers.');\n            const registrations = await navigator.serviceWorker.getRegistrations();\n            await Promise.all(registrations.map(registration => registration.unregister()));\n            // eslint-disable-next-line no-console\n            console.info('All existing service workers have been unregistered.');\n        }\n        localStorage.setItem(versionKey, VERSION);\n    };\n    async initialize(workerUrl) {\n        const { serviceWorker } = navigator;\n        let registration = null;\n        if (!serviceWorker) {\n            console.warn('ServiceWorkers not supported in this browser');\n        }\n        else if (serviceWorker.controller) {\n            const scriptURL = serviceWorker.controller.scriptURL;\n            await this.unregisterOldServiceWorkers(scriptURL);\n            registration = (await serviceWorker.getRegistration(scriptURL)) || null;\n            // eslint-disable-next-line no-console\n            console.info('JupyterLite ServiceWorker was already registered');\n        }\n        if (!registration && serviceWorker) {\n            try {\n                // eslint-disable-next-line no-console\n                console.info('Registering new JupyterLite ServiceWorker', workerUrl);\n                registration = await serviceWorker.register(workerUrl);\n                // eslint-disable-next-line no-console\n                console.info('JupyterLite ServiceWorker was sucessfully registered');\n            }\n            catch (err) {\n                console.warn(err);\n                console.warn(`JupyterLite ServiceWorker registration unexpectedly failed: ${err}`);\n            }\n        }\n        this._setRegistration(registration);\n        if (!registration) {\n            this._ready.reject(void 0);\n        }\n        else {\n            this._ready.resolve(void 0);\n            setTimeout(this._pingServiceWorker, 20000);\n        }\n    }\n    _pingServiceWorker = async () => {\n        const response = await fetch(SW_PING_ENDPOINT);\n        const text = await response.text();\n        if (text === 'ok') {\n            setTimeout(this._pingServiceWorker, 20000);\n        }\n    };\n    _setRegistration(registration) {\n        this._registration = registration;\n        this._registrationChanged.emit(this._registration);\n    }\n    _registration = null;\n    _registrationChanged = new Signal(this);\n    _ready = new PromiseDelegate();\n}\n//# sourceMappingURL=service-manager.js.map","/*\n * Copyright (c) 2021-2023 Datalayer, Inc.\n *\n * MIT License\n */\nimport { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { MIME, FILE } from './tokens';\nimport { PromiseDelegate } from '@lumino/coreutils';\n/**\n * The name of the local storage.\n */\nconst DEFAULT_STORAGE_NAME = 'JupyterLite Storage';\n/**\n * The number of checkpoints to save.\n */\nconst N_CHECKPOINTS = 5;\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder('utf-8');\n/**\n * A class to handle requests to /api/contents\n */\nexport class Contents {\n    /**\n     * Construct a new localForage-powered contents provider\n     */\n    constructor(options) {\n        this._localforage = options.localforage;\n        this._storageName = options.storageName || DEFAULT_STORAGE_NAME;\n        this._storageDrivers = options.storageDrivers || null;\n        this._ready = new PromiseDelegate();\n    }\n    /**\n     * Finish any initialization after server has started and all extensions are applied.\n     */\n    async initialize() {\n        await this.initStorage();\n        this._ready.resolve(void 0);\n    }\n    /**\n     * Initialize all storage instances\n     */\n    async initStorage() {\n        this._storage = this.createDefaultStorage();\n        this._counters = this.createDefaultCounters();\n        this._checkpoints = this.createDefaultCheckpoints();\n    }\n    /**\n     * A promise that resolves once all storage is fully initialized.\n     */\n    get ready() {\n        return this._ready.promise;\n    }\n    /**\n     * A lazy reference to the underlying storage.\n     */\n    get storage() {\n        return this.ready.then(() => this._storage);\n    }\n    /**\n     * A lazy reference to the underlying counters.\n     */\n    get counters() {\n        return this.ready.then(() => this._counters);\n    }\n    /**\n     * A lazy reference to the underlying checkpoints.\n     */\n    get checkpoints() {\n        return this.ready.then(() => this._checkpoints);\n    }\n    /**\n     * Get default options for localForage instances\n     */\n    get defaultStorageOptions() {\n        const driver = this._storageDrivers && this._storageDrivers.length\n            ? this._storageDrivers\n            : null;\n        return {\n            version: 1,\n            name: this._storageName,\n            ...(driver ? { driver } : {}),\n        };\n    }\n    /**\n     * Initialize the default storage for contents.\n     */\n    createDefaultStorage() {\n        return this._localforage.createInstance({\n            description: 'Offline Storage for Notebooks and Files',\n            storeName: 'files',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Initialize the default storage for counting file suffixes.\n     */\n    createDefaultCounters() {\n        return this._localforage.createInstance({\n            description: 'Store the current file suffix counters',\n            storeName: 'counters',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Create the default checkpoint storage.\n     */\n    createDefaultCheckpoints() {\n        return this._localforage.createInstance({\n            description: 'Offline Storage for Checkpoints',\n            storeName: 'checkpoints',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Create a new untitled file or directory in the specified directory path.\n     *\n     * @param options: The options used to create the file.\n     *\n     * @returns A promise which resolves with the created file content when the file is created.\n     */\n    async newUntitled(options) {\n        const path = options?.path ?? '';\n        const type = options?.type ?? 'notebook';\n        const created = new Date().toISOString();\n        let dirname = PathExt.dirname(path);\n        const basename = PathExt.basename(path);\n        const extname = PathExt.extname(path);\n        const item = await this.get(dirname);\n        // handle the case of \"Save As\", where the path points to the new file\n        // to create, e.g. subfolder/example-copy.ipynb\n        let name = '';\n        if (path && !extname && item) {\n            // directory\n            dirname = `${path}/`;\n            name = '';\n        }\n        else if (dirname && basename) {\n            // file in a subfolder\n            dirname = `${dirname}/`;\n            name = basename;\n        }\n        else {\n            // file at the top level\n            dirname = '';\n            name = path;\n        }\n        let file;\n        switch (type) {\n            case 'directory': {\n                const counter = await this._incrementCounter('directory');\n                name = `Untitled Folder${counter || ''}`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format: 'json',\n                    mimetype: '',\n                    content: null,\n                    size: 0,\n                    writable: true,\n                    type: 'directory',\n                };\n                break;\n            }\n            case 'notebook': {\n                const counter = await this._incrementCounter('notebook');\n                name = name || `Untitled${counter || ''}.ipynb`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format: 'json',\n                    mimetype: MIME.JSON,\n                    content: Private.EMPTY_NB,\n                    size: encoder.encode(JSON.stringify(Private.EMPTY_NB)).length,\n                    writable: true,\n                    type: 'notebook',\n                };\n                break;\n            }\n            default: {\n                const ext = options?.ext ?? '.txt';\n                const counter = await this._incrementCounter('file');\n                const mimetype = FILE.getType(ext) || MIME.OCTET_STREAM;\n                let format;\n                if (FILE.hasFormat(ext, 'text') || mimetype.indexOf('text') !== -1) {\n                    format = 'text';\n                }\n                else if (ext.indexOf('json') !== -1 || ext.indexOf('ipynb') !== -1) {\n                    format = 'json';\n                }\n                else {\n                    format = 'base64';\n                }\n                name = name || `untitled${counter || ''}${ext}`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format,\n                    mimetype,\n                    content: '',\n                    size: 0,\n                    writable: true,\n                    type: 'file',\n                };\n                break;\n            }\n        }\n        const key = file.path;\n        await (await this.storage).setItem(key, file);\n        return file;\n    }\n    /**\n     * Copy a file into a given directory.\n     *\n     * @param path - The original file path.\n     * @param toDir - The destination directory path.\n     *\n     * @returns A promise which resolves with the new contents model when the\n     *  file is copied.\n     *\n     * #### Notes\n     * The server will select the name of the copied file.\n     */\n    async copy(path, toDir) {\n        let name = PathExt.basename(path);\n        toDir = toDir === '' ? '' : `${PathExt.removeSlash(toDir)}/`;\n        // TODO: better handle naming collisions with existing files\n        while (await this.get(`${toDir}${name}`, { content: true })) {\n            const ext = PathExt.extname(name);\n            const base = name.replace(ext, '');\n            name = `${base} (copy)${ext}`;\n        }\n        const toPath = `${toDir}${name}`;\n        let item = await this.get(path, { content: true });\n        if (!item) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        item = {\n            ...item,\n            name,\n            path: toPath,\n        };\n        await (await this.storage).setItem(toPath, item);\n        return item;\n    }\n    /**\n     * Get a file or directory.\n     *\n     * @param path: The path to the file.\n     * @param options: The options used to fetch the file.\n     *\n     * @returns A promise which resolves with the file content.\n     */\n    async get(path, options) {\n        // remove leading slash\n        path = decodeURIComponent(path.replace(/^\\//, ''));\n        if (path === '') {\n            return await this._getFolder(path);\n        }\n        const storage = await this.storage;\n        const item = await storage.getItem(path);\n        const serverItem = await this._getServerContents(path, options);\n        const model = (item || serverItem);\n        if (!model) {\n            return null;\n        }\n        if (!options?.content) {\n            return {\n                size: 0,\n                ...model,\n                content: null,\n            };\n        }\n        // for directories, find all files with the path as the prefix\n        if (model.type === 'directory') {\n            const contentMap = new Map();\n            await storage.iterate((file, key) => {\n                // use an additional slash to not include the directory itself\n                if (key === `${path}/${file.name}`) {\n                    contentMap.set(file.name, file);\n                }\n            });\n            const serverContents = serverItem\n                ? serverItem.content\n                : Array.from((await this._getServerDirectory(path)).values());\n            for (const file of serverContents) {\n                if (!contentMap.has(file.name)) {\n                    contentMap.set(file.name, file);\n                }\n            }\n            const content = [...contentMap.values()];\n            return {\n                name: PathExt.basename(path),\n                path,\n                last_modified: model.last_modified,\n                created: model.created,\n                format: 'json',\n                mimetype: MIME.JSON,\n                content,\n                size: 0,\n                writable: true,\n                type: 'directory',\n            };\n        }\n        return model;\n    }\n    /**\n     * Rename a file or directory.\n     *\n     * @param oldLocalPath - The original file path.\n     * @param newLocalPath - The new file path.\n     *\n     * @returns A promise which resolves with the new file content model when the file is renamed.\n     */\n    async rename(oldLocalPath, newLocalPath) {\n        const path = decodeURIComponent(oldLocalPath);\n        const file = await this.get(path, { content: true });\n        if (!file) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        const modified = new Date().toISOString();\n        const name = PathExt.basename(newLocalPath);\n        const newFile = {\n            ...file,\n            name,\n            path: newLocalPath,\n            last_modified: modified,\n        };\n        const storage = await this.storage;\n        await storage.setItem(newLocalPath, newFile);\n        // remove the old file\n        await storage.removeItem(path);\n        // remove the corresponding checkpoint\n        await (await this.checkpoints).removeItem(path);\n        // if a directory, recurse through all children\n        if (file.type === 'directory') {\n            let child;\n            for (child of file.content) {\n                await this.rename(URLExt.join(oldLocalPath, child.name), URLExt.join(newLocalPath, child.name));\n            }\n        }\n        return newFile;\n    }\n    /**\n     * Save a file.\n     *\n     * @param path - The desired file path.\n     * @param options - Optional overrides to the model.\n     *\n     * @returns A promise which resolves with the file content model when the file is saved.\n     */\n    async save(path, options = {}) {\n        path = decodeURIComponent(path);\n        // process the file if coming from an upload\n        const ext = PathExt.extname(options.name ?? '');\n        const chunk = options.chunk;\n        // retrieve the content if it is a later chunk or the last one\n        // the new content will then be appended to the existing one\n        const appendChunk = chunk ? chunk > 1 || chunk === -1 : false;\n        let item = await this.get(path, { content: appendChunk });\n        if (!item) {\n            item = await this.newUntitled({ path, ext, type: 'file' });\n        }\n        if (!item) {\n            return null;\n        }\n        // keep a reference to the original content\n        const originalContent = item.content;\n        const modified = new Date().toISOString();\n        // override with the new values\n        item = {\n            ...item,\n            ...options,\n            last_modified: modified,\n        };\n        if (options.content && options.format === 'base64') {\n            const lastChunk = chunk ? chunk === -1 : true;\n            const contentBinaryString = this._handleUploadChunk(options.content, originalContent, appendChunk);\n            if (ext === '.ipynb') {\n                const content = lastChunk\n                    ? JSON.parse(decoder.decode(this._binaryStringToBytes(contentBinaryString)))\n                    : contentBinaryString;\n                item = {\n                    ...item,\n                    content,\n                    format: 'json',\n                    type: 'notebook',\n                    size: contentBinaryString.length,\n                };\n            }\n            else if (FILE.hasFormat(ext, 'json')) {\n                const content = lastChunk\n                    ? JSON.parse(decoder.decode(this._binaryStringToBytes(contentBinaryString)))\n                    : contentBinaryString;\n                item = {\n                    ...item,\n                    content,\n                    format: 'json',\n                    type: 'file',\n                    size: contentBinaryString.length,\n                };\n            }\n            else if (FILE.hasFormat(ext, 'text')) {\n                const content = lastChunk\n                    ? decoder.decode(this._binaryStringToBytes(contentBinaryString))\n                    : contentBinaryString;\n                item = {\n                    ...item,\n                    content,\n                    format: 'text',\n                    type: 'file',\n                    size: contentBinaryString.length,\n                };\n            }\n            else {\n                const content = lastChunk\n                    ? btoa(contentBinaryString)\n                    : contentBinaryString;\n                item = {\n                    ...item,\n                    content,\n                    format: 'base64',\n                    type: 'file',\n                    size: contentBinaryString.length,\n                };\n            }\n        }\n        // fixup content sizes if necessary\n        if (item.content) {\n            switch (options.format) {\n                case 'json': {\n                    item = {\n                        ...item,\n                        size: encoder.encode(JSON.stringify(item.content)).length,\n                    };\n                    break;\n                }\n                case 'text': {\n                    item = { ...item, size: encoder.encode(item.content).length };\n                    break;\n                }\n                // base64 save was already handled above\n                case 'base64': {\n                    break;\n                }\n                default: {\n                    item = { ...item, size: 0 };\n                    break;\n                }\n            }\n        }\n        else {\n            item = { ...item, size: 0 };\n        }\n        await (await this.storage).setItem(path, item);\n        return item;\n    }\n    /**\n     * Delete a file from browser storage.\n     *\n     * Has no effect on server-backed files, which will re-appear with their\n     * original timestamp.\n     *\n     * @param path - The path to the file.\n     */\n    async delete(path) {\n        path = decodeURIComponent(path);\n        const slashed = `${path}/`;\n        const toDelete = (await (await this.storage).keys()).filter(key => key === path || key.startsWith(slashed));\n        await Promise.all(toDelete.map(this.forgetPath, this));\n    }\n    /**\n     * Remove the localForage and checkpoints for a path.\n     *\n     * @param path - The path to the file\n     */\n    async forgetPath(path) {\n        await Promise.all([\n            (await this.storage).removeItem(path),\n            (await this.checkpoints).removeItem(path),\n        ]);\n    }\n    /**\n     * Create a checkpoint for a file.\n     *\n     * @param path - The path of the file.\n     *\n     * @returns A promise which resolves with the new checkpoint model when the\n     *   checkpoint is created.\n     */\n    async createCheckpoint(path) {\n        const checkpoints = await this.checkpoints;\n        path = decodeURIComponent(path);\n        const item = await this.get(path, { content: true });\n        if (!item) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        const copies = ((await checkpoints.getItem(path)) ?? []).filter(Boolean);\n        copies.push(item);\n        // keep only a certain amount of checkpoints per file\n        if (copies.length > N_CHECKPOINTS) {\n            copies.splice(0, copies.length - N_CHECKPOINTS);\n        }\n        await checkpoints.setItem(path, copies);\n        const id = `${copies.length - 1}`;\n        return { id, last_modified: item.last_modified };\n    }\n    /**\n     * List available checkpoints for a file.\n     *\n     * @param path - The path of the file.\n     *\n     * @returns A promise which resolves with a list of checkpoint models for\n     *    the file.\n     */\n    async listCheckpoints(path) {\n        const copies = (await (await this.checkpoints).getItem(path)) || [];\n        return copies.filter(Boolean).map(this.normalizeCheckpoint, this);\n    }\n    normalizeCheckpoint(model, id) {\n        return { id: id.toString(), last_modified: model.last_modified };\n    }\n    /**\n     * Restore a file to a known checkpoint state.\n     *\n     * @param path - The path of the file.\n     * @param checkpointID - The id of the checkpoint to restore.\n     *\n     * @returns A promise which resolves when the checkpoint is restored.\n     */\n    async restoreCheckpoint(path, checkpointID) {\n        path = decodeURIComponent(path);\n        const copies = ((await (await this.checkpoints).getItem(path)) ||\n            []);\n        const id = parseInt(checkpointID);\n        const item = copies[id];\n        await (await this.storage).setItem(path, item);\n    }\n    /**\n     * Delete a checkpoint for a file.\n     *\n     * @param path - The path of the file.\n     * @param checkpointID - The id of the checkpoint to delete.\n     *\n     * @returns A promise which resolves when the checkpoint is deleted.\n     */\n    async deleteCheckpoint(path, checkpointID) {\n        path = decodeURIComponent(path);\n        const copies = ((await (await this.checkpoints).getItem(path)) ||\n            []);\n        const id = parseInt(checkpointID);\n        copies.splice(id, 1);\n        await (await this.checkpoints).setItem(path, copies);\n    }\n    /**\n     * Handle an upload chunk for a file.\n     * each chunk is base64 encoded, so we need to decode it and append it to the\n     * original content.\n     * @param newContent the new content to process, base64 encoded\n     * @param originalContent the original content, must be null or a binary string if chunked is true\n     * @param appendChunk whether the chunk should be appended to the originalContent\n     *\n     *\n     * @returns the decoded binary string, appended to the original content if requested\n     * /\n     */\n    _handleUploadChunk(newContent, originalContent, appendChunk) {\n        const newContentBinaryString = atob(newContent);\n        const contentBinaryString = appendChunk\n            ? originalContent + newContentBinaryString\n            : newContentBinaryString;\n        return contentBinaryString;\n    }\n    /**\n     * Convert a binary string to an Uint8Array\n     * @param binaryString the binary string\n     * @returns the bytes of the binary string\n     */\n    _binaryStringToBytes(binaryString) {\n        const bytes = new Uint8Array(binaryString.length);\n        for (let i = 0; i < binaryString.length; i++) {\n            bytes[i] = binaryString.charCodeAt(i);\n        }\n        return bytes;\n    }\n    /**\n     * retrieve the contents for this path from the union of local storage and\n     * `api/contents/{path}/all.json`.\n     *\n     * @param path - The contents path to retrieve\n     *\n     * @returns A promise which resolves with a Map of contents, keyed by local file name\n     */\n    async _getFolder(path) {\n        const content = new Map();\n        const storage = await this.storage;\n        await storage.iterate((file, key) => {\n            if (key.includes('/')) {\n                return;\n            }\n            content.set(file.path, file);\n        });\n        // layer in contents that don't have local overwrites\n        for (const file of (await this._getServerDirectory(path)).values()) {\n            if (!content.has(file.path)) {\n                content.set(file.path, file);\n            }\n        }\n        if (path && content.size === 0) {\n            return null;\n        }\n        return {\n            name: '',\n            path,\n            last_modified: new Date(0).toISOString(),\n            created: new Date(0).toISOString(),\n            format: 'json',\n            mimetype: MIME.JSON,\n            content: Array.from(content.values()),\n            size: 0,\n            writable: true,\n            type: 'directory',\n        };\n    }\n    /**\n     * Attempt to recover the model from `{:path}/__all__.json` file, fall back to\n     * deriving the model (including content) off the file in `/files/`. Otherwise\n     * return `null`.\n     */\n    async _getServerContents(path, options) {\n        const name = PathExt.basename(path);\n        const parentContents = await this._getServerDirectory(URLExt.join(path, '..'));\n        let model = parentContents.get(name);\n        if (!model) {\n            return null;\n        }\n        model = model || {\n            name,\n            path,\n            last_modified: new Date(0).toISOString(),\n            created: new Date(0).toISOString(),\n            format: 'text',\n            mimetype: MIME.PLAIN_TEXT,\n            type: 'file',\n            writable: true,\n            size: 0,\n            content: '',\n        };\n        if (options?.content) {\n            if (model.type === 'directory') {\n                const serverContents = await this._getServerDirectory(path);\n                model = { ...model, content: Array.from(serverContents.values()) };\n            }\n            else {\n                const fileUrl = URLExt.join(PageConfig.getBaseUrl(), 'files', path);\n                const response = await fetch(fileUrl);\n                if (!response.ok) {\n                    return null;\n                }\n                const mimetype = model.mimetype || response.headers.get('Content-Type');\n                const ext = PathExt.extname(name);\n                if (model.type === 'notebook' ||\n                    FILE.hasFormat(ext, 'json') ||\n                    mimetype?.indexOf('json') !== -1 ||\n                    path.match(/\\.(ipynb|[^/]*json[^/]*)$/)) {\n                    const contentText = await response.text();\n                    model = {\n                        ...model,\n                        content: JSON.parse(contentText),\n                        format: 'json',\n                        mimetype: model.mimetype || MIME.JSON,\n                        size: encoder.encode(contentText).length,\n                    };\n                }\n                else if (FILE.hasFormat(ext, 'text') ||\n                    mimetype.indexOf('text') !== -1) {\n                    const contentText = await response.text();\n                    model = {\n                        ...model,\n                        content: contentText,\n                        format: 'text',\n                        mimetype: mimetype || MIME.PLAIN_TEXT,\n                        size: encoder.encode(contentText).length,\n                    };\n                }\n                else {\n                    const contentBuffer = await response.arrayBuffer();\n                    const contentBytes = new Uint8Array(contentBuffer);\n                    model = {\n                        ...model,\n                        content: btoa(contentBytes.reduce(this.reduceBytesToString, '')),\n                        format: 'base64',\n                        mimetype: mimetype || MIME.OCTET_STREAM,\n                        size: contentBytes.length,\n                    };\n                }\n            }\n        }\n        return model;\n    }\n    /**\n     * A reducer for turning arbitrary binary into a string\n     */\n    reduceBytesToString = (data, byte) => {\n        return data + String.fromCharCode(byte);\n    };\n    /**\n     * retrieve the contents for this path from `__index__.json` in the appropriate\n     * folder.\n     *\n     * @param newLocalPath - The new file path.\n     *\n     * @returns A promise which resolves with a Map of contents, keyed by local file name\n     */\n    async _getServerDirectory(path) {\n        const content = this._serverContents.get(path) || new Map();\n        if (!this._serverContents.has(path)) {\n            const apiURL = URLExt.join(PageConfig.getBaseUrl(), 'api/contents', path, 'all.json');\n            try {\n                const response = await fetch(apiURL);\n                const json = JSON.parse(await response.text());\n                for (const file of json['content']) {\n                    content.set(file.name, file);\n                }\n            }\n            catch (err) {\n                console.warn(`don't worry, about ${err}... nothing's broken. If there had been a\n          file at ${apiURL}, you might see some more files.`);\n            }\n            this._serverContents.set(path, content);\n        }\n        return content;\n    }\n    /**\n     * Increment the counter for a given file type.\n     * Used to avoid collisions when creating new untitled files.\n     *\n     * @param type The file type to increment the counter for.\n     */\n    async _incrementCounter(type) {\n        const counters = await this.counters;\n        const current = (await counters.getItem(type)) ?? -1;\n        const counter = current + 1;\n        await counters.setItem(type, counter);\n        return counter;\n    }\n    _serverContents = new Map();\n    _storageName = DEFAULT_STORAGE_NAME;\n    _storageDrivers = null;\n    _ready;\n    _storage;\n    _counters;\n    _checkpoints;\n    _localforage;\n}\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The content for an empty notebook.\n     */\n    Private.EMPTY_NB = {\n        metadata: {\n            orig_nbformat: 4,\n        },\n        nbformat_minor: 5,\n        nbformat: 4,\n        cells: [],\n    };\n})(Private || (Private = {}));\n//# sourceMappingURL=contents.js.map","/*\n * Copyright (c) 2021-2023 Datalayer, Inc.\n *\n * MIT License\n */\nimport { DRIVE_API_PATH } from './drivefs';\nimport { DriveContentsProcessor, } from './drivecontents';\n/** A broadcaster for the ServiceWorker */\nexport class BroadcastChannelWrapper {\n    isDisposed = false;\n    constructor(options) {\n        this._contents = options.contents;\n        this._driveContentsProcessor = new DriveContentsProcessor({\n            contentsManager: this._contents,\n        });\n    }\n    get enabled() {\n        return this._enabled;\n    }\n    enable() {\n        if (this._channel) {\n            console.warn('BroadcastChannel already created and enabled');\n            return;\n        }\n        this._channel = new BroadcastChannel(DRIVE_API_PATH);\n        this._channel.addEventListener('message', this._onMessage);\n        this._enabled = true;\n    }\n    disable() {\n        if (this._channel) {\n            this._channel.removeEventListener('message', this._onMessage);\n            this._channel = null;\n        }\n        this._enabled = false;\n    }\n    /** Clean up the broadcaster. */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this.disable();\n        this.isDisposed = true;\n    }\n    /** Handle a message received on the BroadcastChannel */\n    _onMessage = async (event) => {\n        if (!this._channel) {\n            return;\n        }\n        const request = event.data;\n        const receiver = request?.receiver;\n        if (receiver !== 'broadcast.ts') {\n            // Message is not meant for us\n            return;\n        }\n        const response = await this._driveContentsProcessor.processDriveRequest(request);\n        this._channel.postMessage(response);\n    };\n    _channel = null;\n    _contents;\n    _driveContentsProcessor;\n    _enabled = false;\n}\n//# sourceMappingURL=broadcast.js.map","const E_TIMEOUT = new Error('timeout while waiting for mutex to become available');\nconst E_ALREADY_LOCKED = new Error('mutex already locked');\nconst E_CANCELED = new Error('request for lock canceled');\n\nvar __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Semaphore {\n    constructor(_maxConcurrency, _cancelError = E_CANCELED) {\n        this._maxConcurrency = _maxConcurrency;\n        this._cancelError = _cancelError;\n        this._queue = [];\n        this._waiters = [];\n        if (_maxConcurrency <= 0) {\n            throw new Error('semaphore must be initialized to a positive value');\n        }\n        this._value = _maxConcurrency;\n    }\n    acquire() {\n        const locked = this.isLocked();\n        const ticketPromise = new Promise((resolve, reject) => this._queue.push({ resolve, reject }));\n        if (!locked)\n            this._dispatch();\n        return ticketPromise;\n    }\n    runExclusive(callback) {\n        return __awaiter$2(this, void 0, void 0, function* () {\n            const [value, release] = yield this.acquire();\n            try {\n                return yield callback(value);\n            }\n            finally {\n                release();\n            }\n        });\n    }\n    waitForUnlock() {\n        return __awaiter$2(this, void 0, void 0, function* () {\n            if (!this.isLocked()) {\n                return Promise.resolve();\n            }\n            const waitPromise = new Promise((resolve) => this._waiters.push({ resolve }));\n            return waitPromise;\n        });\n    }\n    isLocked() {\n        return this._value <= 0;\n    }\n    /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */\n    release() {\n        if (this._maxConcurrency > 1) {\n            throw new Error('this method is unavailable on semaphores with concurrency > 1; use the scoped release returned by acquire instead');\n        }\n        if (this._currentReleaser) {\n            const releaser = this._currentReleaser;\n            this._currentReleaser = undefined;\n            releaser();\n        }\n    }\n    cancel() {\n        this._queue.forEach((ticket) => ticket.reject(this._cancelError));\n        this._queue = [];\n    }\n    _dispatch() {\n        const nextTicket = this._queue.shift();\n        if (!nextTicket)\n            return;\n        let released = false;\n        this._currentReleaser = () => {\n            if (released)\n                return;\n            released = true;\n            this._value++;\n            this._resolveWaiters();\n            this._dispatch();\n        };\n        nextTicket.resolve([this._value--, this._currentReleaser]);\n    }\n    _resolveWaiters() {\n        this._waiters.forEach((waiter) => waiter.resolve());\n        this._waiters = [];\n    }\n}\n\nvar __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Mutex {\n    constructor(cancelError) {\n        this._semaphore = new Semaphore(1, cancelError);\n    }\n    acquire() {\n        return __awaiter$1(this, void 0, void 0, function* () {\n            const [, releaser] = yield this._semaphore.acquire();\n            return releaser;\n        });\n    }\n    runExclusive(callback) {\n        return this._semaphore.runExclusive(() => callback());\n    }\n    isLocked() {\n        return this._semaphore.isLocked();\n    }\n    waitForUnlock() {\n        return this._semaphore.waitForUnlock();\n    }\n    /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */\n    release() {\n        this._semaphore.release();\n    }\n    cancel() {\n        return this._semaphore.cancel();\n    }\n}\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {\n    return {\n        acquire: () => new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            let isTimeout = false;\n            const handle = setTimeout(() => {\n                isTimeout = true;\n                reject(timeoutError);\n            }, timeout);\n            try {\n                const ticket = yield sync.acquire();\n                if (isTimeout) {\n                    const release = Array.isArray(ticket) ? ticket[1] : ticket;\n                    release();\n                }\n                else {\n                    clearTimeout(handle);\n                    resolve(ticket);\n                }\n            }\n            catch (e) {\n                if (!isTimeout) {\n                    clearTimeout(handle);\n                    reject(e);\n                }\n            }\n        })),\n        runExclusive(callback) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let release = () => undefined;\n                try {\n                    const ticket = yield this.acquire();\n                    if (Array.isArray(ticket)) {\n                        release = ticket[1];\n                        return yield callback(ticket[0]);\n                    }\n                    else {\n                        release = ticket;\n                        return yield callback();\n                    }\n                }\n                finally {\n                    release();\n                }\n            });\n        },\n        /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */\n        release() {\n            sync.release();\n        },\n        cancel() {\n            return sync.cancel();\n        },\n        waitForUnlock: () => sync.waitForUnlock(),\n        isLocked: () => sync.isLocked(),\n    };\n}\n\n// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types\nfunction tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return withTimeout(sync, 0, alreadyAcquiredError);\n}\n\nexport { E_ALREADY_LOCKED, E_CANCELED, E_TIMEOUT, Mutex, Semaphore, tryAcquire, withTimeout };\n","/*\n * Copyright (c) 2021-2023 Datalayer, Inc.\n *\n * MIT License\n */\nimport { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { ObservableMap } from '@jupyterlab/observables';\nimport { KernelAPI } from '@jupyterlab/services';\nimport { deserialize, serialize, } from '@jupyterlab/services/lib/kernel/serialize';\nimport { supportedKernelWebSocketProtocols } from '@jupyterlab/services/lib/kernel/messages';\nimport { UUID } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport { Mutex } from 'async-mutex';\nimport { Server as WebSocketServer, } from 'mock-socket';\n/**\n * Use the default kernel wire protocol.\n */\nconst KERNEL_WEBSOCKET_PROTOCOL = supportedKernelWebSocketProtocols.v1KernelWebsocketJupyterOrg;\n/**\n * A class to handle requests to /api/kernels\n */\nexport class Kernels {\n    /**\n     * Construct a new Kernels\n     *\n     * @param options The instantiation options\n     */\n    constructor(options) {\n        const { kernelspecs } = options;\n        this._kernelspecs = kernelspecs;\n        // Forward the changed signal from _kernels\n        this._kernels.changed.connect((_, args) => {\n            this._changed.emit(args);\n        });\n    }\n    /**\n     * Signal emitted when the kernels map changes\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Start a new kernel.\n     *\n     * @param options The kernel start options.\n     */\n    async startNew(options) {\n        const { id, name, location } = options;\n        const factory = this._kernelspecs.factories.get(name);\n        // bail if there is no factory associated with the requested kernel\n        if (!factory) {\n            console.error('No factory associated with', name, this._kernelspecs.factories);\n            return { id, name };\n        }\n        // create a synchronization mechanism to allow only one message\n        // to be processed at a time\n        const mutex = new Mutex();\n        // hook a new client to a kernel\n        const hook = (kernelId, clientId, socket) => {\n            const kernel = this._kernels.get(kernelId);\n            if (!kernel) {\n                throw Error(`No kernel ${kernelId}`);\n            }\n            this._clients.set(clientId, socket);\n            this._kernelClients.get(kernelId)?.add(clientId);\n            const processMsg = async (msg) => {\n                await mutex.runExclusive(async () => {\n                    await kernel.ready;\n                    await kernel.handleMessage(msg);\n                });\n            };\n            socket.on('message', async (message) => {\n                let msg;\n                if (message instanceof ArrayBuffer) {\n                    message = new Uint8Array(message).buffer;\n                    msg = deserialize(message, KERNEL_WEBSOCKET_PROTOCOL);\n                }\n                else if (typeof message === 'string') {\n                    const encoder = new TextEncoder();\n                    const encodedData = encoder.encode(message);\n                    msg = deserialize(encodedData.buffer, KERNEL_WEBSOCKET_PROTOCOL);\n                }\n                else {\n                    return;\n                }\n                // TODO Find a better solution for this?\n                // input-reply is asynchronous, must not be processed like other messages\n                if (msg.header.msg_type === 'input_reply') {\n                    kernel.handleMessage(msg);\n                }\n                else {\n                    void processMsg(msg);\n                }\n            });\n            const removeClient = () => {\n                this._clients.delete(clientId);\n                this._kernelClients.get(kernelId)?.delete(clientId);\n            };\n            kernel.disposed.connect(removeClient);\n            socket.onclose = removeClient;\n        };\n        // ensure kernel id\n        const kernelId = id ?? UUID.uuid4();\n        // There is one server per kernel which handles multiple clients\n        const kernelUrl = URLExt.join(Kernels.WS_BASE_URL, KernelAPI.KERNEL_SERVICE_URL, encodeURIComponent(kernelId), 'channels');\n        const runningKernel = this._kernels.get(kernelId);\n        if (runningKernel) {\n            return {\n                id: runningKernel.id,\n                name: runningKernel.name,\n            };\n        }\n        // start the kernel\n        const sendMessage = (msg) => {\n            const clientId = msg.header.session;\n            const socket = this._clients.get(clientId);\n            if (!socket) {\n                console.warn(`Trying to send message on removed socket for kernel ${kernelId}`);\n                return;\n            }\n            const message = serialize(msg, KERNEL_WEBSOCKET_PROTOCOL);\n            // process iopub messages\n            if (msg.channel === 'iopub') {\n                const clients = this._kernelClients.get(kernelId);\n                clients?.forEach(id => {\n                    this._clients.get(id)?.send(message);\n                });\n                return;\n            }\n            socket.send(message);\n        };\n        const kernel = await factory({\n            id: kernelId,\n            sendMessage,\n            name,\n            location,\n        });\n        this._kernels.set(kernelId, kernel);\n        this._kernelClients.set(kernelId, new Set());\n        // create the websocket server for the kernel\n        const wsServer = new WebSocketServer(kernelUrl, {\n            mock: false,\n            selectProtocol: () => KERNEL_WEBSOCKET_PROTOCOL,\n        });\n        wsServer.on('connection', (socket) => {\n            const url = new URL(socket.url);\n            const clientId = url.searchParams.get('session_id') ?? '';\n            hook(kernelId, clientId, socket);\n        });\n        // clean up closed connection\n        wsServer.on('close', () => {\n            this._clients.keys().forEach(clientId => {\n                const socket = this._clients.get(clientId);\n                if (socket?.readyState === WebSocket.CLOSED) {\n                    this._clients.delete(clientId);\n                    this._kernelClients.get(kernelId)?.delete(clientId);\n                }\n            });\n        });\n        // cleanup on kernel shutdown\n        kernel.disposed.connect(() => {\n            wsServer.close();\n            this._kernels.delete(kernelId);\n            this._kernelClients.delete(kernelId);\n        });\n        return {\n            id: kernel.id,\n            name: kernel.name,\n        };\n    }\n    /**\n     * Restart a kernel.\n     *\n     * @param kernelId The kernel id.\n     */\n    async restart(kernelId) {\n        const kernel = this._kernels.get(kernelId);\n        if (!kernel) {\n            throw Error(`Kernel ${kernelId} does not exist`);\n        }\n        const { id, name, location } = kernel;\n        kernel.dispose();\n        return this.startNew({ id, name, location });\n    }\n    /**\n     * List the running kernels.\n     */\n    async list() {\n        return [...this._kernels.values()].map(kernel => ({\n            id: kernel.id,\n            name: kernel.name,\n        }));\n    }\n    /**\n     * Shut down a kernel.\n     *\n     * @param id The kernel id.\n     */\n    async shutdown(id) {\n        this._kernels.delete(id)?.dispose();\n    }\n    /**\n     * Get a kernel by id\n     */\n    async get(id) {\n        return this._kernels.get(id);\n    }\n    _kernels = new ObservableMap();\n    _clients = new ObservableMap();\n    _kernelClients = new ObservableMap();\n    _kernelspecs;\n    _changed = new Signal(this);\n}\n/**\n * A namespace for Kernels statics.\n */\n(function (Kernels) {\n    /**\n     * The base url for the Kernels manager\n     */\n    Kernels.WS_BASE_URL = PageConfig.getBaseUrl().replace(/^http/, 'ws');\n})(Kernels || (Kernels = {}));\n//# sourceMappingURL=kernels.js.map","/*\n * Copyright (c) 2021-2023 Datalayer, Inc.\n *\n * MIT License\n */\nimport { PageConfig } from '@jupyterlab/coreutils';\nimport { FALLBACK_KERNEL } from './tokens';\n/**\n * A class to handle requests to /api/kernelspecs\n */\nexport class KernelSpecs {\n    /**\n     * Get the kernel specs.\n     */\n    get specs() {\n        if (this._specs.size === 0) {\n            return null;\n        }\n        return {\n            default: this.defaultKernelName,\n            kernelspecs: Object.fromEntries(this._specs),\n        };\n    }\n    /**\n     * Get the default kernel name.\n     */\n    get defaultKernelName() {\n        let defaultKernelName = PageConfig.getOption('defaultKernelName');\n        if (!defaultKernelName && this._specs.size) {\n            const keys = Array.from(this._specs.keys());\n            keys.sort();\n            defaultKernelName = keys[0];\n        }\n        return defaultKernelName || FALLBACK_KERNEL;\n    }\n    /**\n     * Get the kernel factories for the current kernels.\n     */\n    get factories() {\n        return this._factories;\n    }\n    /**\n     * Register a new kernel.\n     *\n     * @param options The options to register a new kernel.\n     */\n    register(options) {\n        const { spec, create } = options;\n        this._specs.set(spec.name, spec);\n        this._factories.set(spec.name, create);\n    }\n    _specs = new Map();\n    _factories = new Map();\n}\n//# sourceMappingURL=kernelspecs.js.map","/*\n * Copyright (c) 2021-2023 Datalayer, Inc.\n *\n * MIT License\n */\nimport { Token } from '@lumino/coreutils';\n/**\n * The token for the localforage singleton.\n */\nexport const ILocalForage = new Token('@jupyterlite/localforge:ILocalForage');\n//# sourceMappingURL=tokens.js.map","function getSerializerPromise(localForageInstance) {\n    if (getSerializerPromise.result) {\n        return getSerializerPromise.result;\n    }\n    if (!localForageInstance || typeof localForageInstance.getSerializer !== 'function') {\n        Promise.reject(new Error('localforage.getSerializer() was not available! ' + 'localforage v1.4+ is required!'));\n    }\n    getSerializerPromise.result = localForageInstance.getSerializer();\n    return getSerializerPromise.result;\n}\n\nfunction executeCallback(promise, callback) {\n    if (callback) {\n        promise.then(function (result) {\n            callback(null, result);\n        }, function (error) {\n            callback(error);\n        });\n    }\n}\n\nvar storageRepository = {};\n\n// Config the localStorage backend, using options set in the config.\nfunction _initStorage(options) {\n    var self = this;\n\n    var dbInfo = {};\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    var database = storageRepository[dbInfo.name] = storageRepository[dbInfo.name] || {};\n    var table = database[dbInfo.storeName] = database[dbInfo.storeName] || {};\n    dbInfo.db = table;\n\n    self._dbInfo = dbInfo;\n\n    return getSerializerPromise(self).then(function (serializer) {\n        dbInfo.serializer = serializer;\n    });\n}\n\nfunction clear(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var db = self._dbInfo.db;\n\n        for (var key in db) {\n            if (db.hasOwnProperty(key)) {\n                delete db[key];\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction getItem(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = self.ready().then(function () {\n        var db = self._dbInfo.db;\n        var result = db[key];\n\n        if (result) {\n            result = self._dbInfo.serializer.deserialize(result);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction iterate(iterator, callback) {\n    var self = this;\n\n    var promise = self.ready().then(function () {\n        var db = self._dbInfo.db;\n\n        var iterationNumber = 1;\n        for (var key in db) {\n            if (db.hasOwnProperty(key)) {\n                var value = db[key];\n\n                if (value) {\n                    value = self._dbInfo.serializer.deserialize(value);\n                }\n\n                value = iterator(value, key, iterationNumber++);\n\n                if (value !== void 0) {\n                    return value;\n                }\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction key(n, callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var db = self._dbInfo.db;\n        var result = null;\n        var index = 0;\n\n        for (var key in db) {\n            if (db.hasOwnProperty(key)) {\n                if (n === index) {\n                    result = key;\n                    break;\n                }\n                index++;\n            }\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var db = self._dbInfo.db;\n        var keys = [];\n\n        for (var key in db) {\n            if (db.hasOwnProperty(key)) {\n                keys.push(key);\n            }\n        }\n\n        return keys;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction length(callback) {\n    var self = this;\n    var promise = self.keys().then(function (keys) {\n        return keys.length;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction removeItem(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = self.ready().then(function () {\n        var db = self._dbInfo.db;\n        if (db.hasOwnProperty(key)) {\n            delete db[key];\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction setItem(key, value, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = self.ready().then(function () {\n        // Convert undefined values to null.\n        // https://github.com/mozilla/localForage/pull/42\n        if (value === undefined) {\n            value = null;\n        }\n\n        // Save the original value to pass to the callback.\n        var originalValue = value;\n\n        function serializeAsync(value) {\n            return new Promise(function (resolve, reject) {\n                self._dbInfo.serializer.serialize(value, function (value, error) {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        resolve(value);\n                    }\n                });\n            });\n        }\n\n        return serializeAsync(value).then(function (value) {\n            var db = self._dbInfo.db;\n            db[key] = value;\n            return originalValue;\n        });\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar memoryStorageDriver = {\n    _driver: 'memoryStorageDriver',\n    _initStorage: _initStorage,\n    // _supports: function() { return true; }\n    iterate: iterate,\n    getItem: getItem,\n    setItem: setItem,\n    removeItem: removeItem,\n    clear: clear,\n    length: length,\n    key: key,\n    keys: keys\n};\n\nexport default memoryStorageDriver;","/*\n * Copyright (c) 2021-2023 Datalayer, Inc.\n *\n * MIT License\n */\nimport { Token } from '@lumino/coreutils';\n/**\n * The token for the sessions service.\n */\nexport const ISessions = new Token('@jupyterlite/session:ISessions');\n//# sourceMappingURL=tokens.js.map","/*\n * Copyright (c) 2021-2023 Datalayer, Inc.\n *\n * MIT License\n */\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { ArrayExt } from '@lumino/algorithm';\nimport { UUID } from '@lumino/coreutils';\n/**\n * A class to handle requests to /api/sessions\n */\nexport class Sessions {\n    /**\n     * Construct a new Sessions.\n     *\n     * @param options The instantiation options for a Sessions.\n     */\n    constructor(options) {\n        this._kernels = options.kernels;\n        // Listen for kernel removals\n        this._kernels.changed.connect((_, args) => {\n            switch (args.type) {\n                case 'remove': {\n                    const kernelId = args.oldValue?.id;\n                    if (!kernelId) {\n                        return;\n                    }\n                    // find the session associated with the kernel\n                    const session = this._sessions.find(s => s.kernel?.id === kernelId);\n                    if (!session) {\n                        return;\n                    }\n                    // Track the kernel ID for restart detection\n                    this._pendingRestarts.add(kernelId);\n                    setTimeout(async () => {\n                        // If after a short delay the kernel hasn't been re-added, it was terminated\n                        if (this._pendingRestarts.has(kernelId)) {\n                            this._pendingRestarts.delete(kernelId);\n                            await this.shutdown(session.id);\n                        }\n                    }, 100);\n                    break;\n                }\n                case 'add': {\n                    // If this was a restart, remove it from pending\n                    const kernelId = args.newValue?.id;\n                    if (!kernelId) {\n                        return;\n                    }\n                    this._pendingRestarts.delete(kernelId);\n                    break;\n                }\n            }\n        });\n    }\n    /**\n     * Get a session by id.\n     *\n     * @param id The id of the session.\n     */\n    async get(id) {\n        const session = this._sessions.find(s => s.id === id);\n        if (!session) {\n            throw Error(`Session ${id} not found`);\n        }\n        return session;\n    }\n    /**\n     * List the running sessions\n     */\n    async list() {\n        return this._sessions;\n    }\n    /**\n     * Patch an existing session.\n     * This can be used to rename a session.\n     *\n     * - path updates session to track renamed paths\n     * - kernel.name starts a new kernel with a given kernelspec\n     *\n     * @param options The options to patch the session.\n     */\n    async patch(options) {\n        const { id, path, name, kernel } = options;\n        const index = this._sessions.findIndex(s => s.id === id);\n        const session = this._sessions[index];\n        if (!session) {\n            throw Error(`Session ${id} not found`);\n        }\n        const patched = {\n            ...session,\n            path: path ?? session.path,\n            name: name ?? session.name,\n        };\n        if (kernel) {\n            // Kernel id takes precedence over name.\n            if (kernel.id) {\n                const session = this._sessions.find(session => session.kernel?.id === kernel?.id);\n                if (session) {\n                    patched.kernel = session.kernel;\n                }\n            }\n            else if (kernel.name) {\n                const newKernel = await this._kernels.startNew({\n                    id: UUID.uuid4(),\n                    name: kernel.name,\n                    location: PathExt.dirname(patched.path),\n                });\n                if (newKernel) {\n                    patched.kernel = newKernel;\n                }\n                // clean up the session on kernel shutdown\n                void this._handleKernelShutdown({\n                    kernelId: newKernel.id,\n                    sessionId: session.id,\n                });\n            }\n        }\n        this._sessions[index] = patched;\n        return patched;\n    }\n    /**\n     * Start a new session\n     * TODO: read path and name\n     *\n     * @param options The options to start a new session.\n     */\n    async startNew(options) {\n        const { path, name } = options;\n        const running = this._sessions.find(s => s.name === name);\n        if (running) {\n            return running;\n        }\n        const kernelName = options.kernel?.name ?? '';\n        const id = options.id ?? UUID.uuid4();\n        const nameOrPath = options.name ?? options.path;\n        const dirname = PathExt.dirname(options.name) || PathExt.dirname(options.path);\n        const hasDrive = nameOrPath.includes(':');\n        const driveName = hasDrive ? nameOrPath.split(':')[0] : '';\n        // add drive name if missing (top level directory)\n        const location = dirname.includes(driveName)\n            ? dirname\n            : `${driveName}:${dirname}`;\n        const kernel = await this._kernels.startNew({\n            id,\n            name: kernelName,\n            location,\n        });\n        const session = {\n            id,\n            path,\n            name: name ?? path,\n            type: 'notebook',\n            kernel: {\n                id: kernel.id,\n                name: kernel.name,\n            },\n        };\n        this._sessions.push(session);\n        // clean up the session on kernel shutdown\n        void this._handleKernelShutdown({ kernelId: id, sessionId: session.id });\n        return session;\n    }\n    /**\n     * Shut down a session.\n     *\n     * @param id The id of the session to shut down.\n     */\n    async shutdown(id) {\n        const session = this._sessions.find(s => s.id === id);\n        if (!session) {\n            throw Error(`Session ${id} not found`);\n        }\n        const kernelId = session.kernel?.id;\n        if (kernelId) {\n            await this._kernels.shutdown(kernelId);\n        }\n        ArrayExt.removeFirstOf(this._sessions, session);\n    }\n    /**\n     * Handle kernel shutdown\n     */\n    async _handleKernelShutdown({ kernelId, sessionId, }) {\n        // No need to handle kernel shutdown here anymore since we're using the changed signal\n    }\n    _kernels;\n    _sessions = [];\n    _pendingRestarts = new Set();\n}\n//# sourceMappingURL=sessions.js.map","/*\n * Copyright (c) 2021-2023 Datalayer, Inc.\n *\n * MIT License\n */\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/**\n * The well-known name of the file. Can actually be configured by alternate\n * implementations, but the default is probably good enough for \"best-effort.\"\n */\nexport const THIRD_PARTY_LICENSES = 'third-party-licenses.json';\n/**\n * The token for the licenses service.\n */\nexport const ILicenses = new Token('@jupyterlite/licenses:ILicenses');\n//# sourceMappingURL=tokens.js.map","/*\n * Copyright (c) 2021-2023 Datalayer, Inc.\n *\n * MIT License\n */\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { URLExt, PageConfig } from '@jupyterlab/coreutils';\nimport { THIRD_PARTY_LICENSES, } from './tokens';\n/**\n * An empty bundle.\n */\nconst EMPTY_BUNDLE = Object.freeze({ packages: [] });\n/**\n * A JupyterLite implementation of the jupyterlab_server licenses route\n */\nexport class Licenses {\n    /**\n     * A GET handler for the licenses\n     */\n    async get() {\n        return {\n            bundles: {\n                ...(await this._getFederated()),\n                [this.appName]: await this._getAppLicenses(),\n            },\n        };\n    }\n    /**\n     * Get the app name (or default).\n     */\n    get appName() {\n        return PageConfig.getOption('appName') || 'JupyterLite';\n    }\n    /**\n     * Get the well-known URL of the app licenses.\n     */\n    get appLicensesUrl() {\n        return URLExt.join(PageConfig.getBaseUrl(), 'build', THIRD_PARTY_LICENSES);\n    }\n    /**\n     * Get the lab extension base url.\n     */\n    get labExtensionsUrl() {\n        return PageConfig.getOption('fullLabextensionsUrl');\n    }\n    /**\n     * Resolve the licenses for the app distribution itself, or the empty bundle.\n     */\n    async _getAppLicenses() {\n        let bundle = EMPTY_BUNDLE;\n        try {\n            const response = await fetch(this.appLicensesUrl);\n            bundle = response.json();\n        }\n        catch (err) {\n            console.warn('Could not resolve licenses for', this.appName);\n        }\n        return bundle;\n    }\n    /**\n     * Resolve the licenses for all federated extensions.\n     */\n    async _getFederated() {\n        const bundles = {};\n        let federated;\n        try {\n            federated = JSON.parse(PageConfig.getOption('federated_extensions'));\n        }\n        catch {\n            return bundles;\n        }\n        const promises = [];\n        for (const ext of federated) {\n            promises.push(this._getOneFederated(ext, bundles));\n        }\n        try {\n            await Promise.all(promises);\n        }\n        catch (err) {\n            console.warn('Error resolving licenses', err);\n        }\n        return bundles;\n    }\n    /**\n     * Update the bundles with the extension's licenses, or the empty bundle.\n     */\n    async _getOneFederated(ext, bundles) {\n        try {\n            const url = URLExt.join(this.labExtensionsUrl, ext.name, 'static', THIRD_PARTY_LICENSES);\n            const response = await fetch(url);\n            bundles[ext.name] = await response.json();\n        }\n        catch {\n            console.warn('Could not resolve licenses for', ext);\n            bundles[ext.name] = EMPTY_BUNDLE;\n        }\n    }\n}\n//# sourceMappingURL=licenses.js.map","/*\n * Copyright (c) 2021-2023 Datalayer, Inc.\n *\n * MIT License\n */\nimport { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport * as json5 from 'json5';\n/**\n * The name of the local storage.\n */\nconst DEFAULT_STORAGE_NAME = 'JupyterLite Storage';\n/**\n * A class to handle requests to /api/settings\n */\nexport class Settings {\n    constructor(options) {\n        this._localforage = options.localforage;\n        this._storageName = options.storageName || DEFAULT_STORAGE_NAME;\n        this._storageDrivers = options.storageDrivers || null;\n        this._ready = new PromiseDelegate();\n    }\n    /**\n     * A promise that resolves when the settings storage is fully initialized\n     */\n    get ready() {\n        return this._ready.promise;\n    }\n    /**\n     * A lazy reference to initialized storage\n     */\n    get storage() {\n        return this.ready.then(() => this._storage);\n    }\n    /**\n     * Finish any initialization after server has started and all extensions are applied.\n     */\n    async initialize() {\n        await this.initStorage();\n        this._ready.resolve(void 0);\n    }\n    /**\n     * Prepare the storage\n     */\n    async initStorage() {\n        this._storage = this.defaultSettingsStorage();\n    }\n    /**\n     * Get default options for localForage instances\n     */\n    get defaultStorageOptions() {\n        const driver = this._storageDrivers?.length ? this._storageDrivers : null;\n        return {\n            version: 1,\n            name: this._storageName,\n            ...(driver ? { driver } : {}),\n        };\n    }\n    /**\n     * Create a settings store.\n     */\n    defaultSettingsStorage() {\n        return this._localforage.createInstance({\n            description: 'Offline Storage for Settings',\n            storeName: 'settings',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Get settings by plugin id\n     *\n     * @param pluginId the id of the plugin\n     *\n     */\n    async get(pluginId) {\n        const all = await this.getAll();\n        const settings = all.settings;\n        const setting = settings.find((setting) => {\n            return setting.id === pluginId;\n        });\n        return setting;\n    }\n    /**\n     * Get all the settings\n     */\n    async getAll() {\n        const allCore = await this._getAll('all.json');\n        let allFederated = [];\n        try {\n            allFederated = await this._getAll('all_federated.json');\n        }\n        catch {\n            // handle the case where there is no federated extension\n        }\n        // JupyterLab 4 expects all settings to be returned in one go\n        // so append the settings from federated plugins to the core ones\n        const all = allCore.concat(allFederated);\n        // return existing user settings if they exist\n        const storage = await this.storage;\n        const settings = await Promise.all(all.map(async (plugin) => {\n            const { id } = plugin;\n            const raw = (await storage.getItem(id)) ?? plugin.raw;\n            return {\n                ...Private.override(plugin),\n                raw,\n                settings: json5.parse(raw),\n            };\n        }));\n        return { settings };\n    }\n    /**\n     * Save settings for a given plugin id\n     *\n     * @param pluginId The id of the plugin\n     * @param raw The raw settings\n     *\n     */\n    async save(pluginId, raw) {\n        await (await this.storage).setItem(pluginId, raw);\n    }\n    /**\n     * Get all the settings for core or federated plugins\n     */\n    async _getAll(file) {\n        const settingsUrl = PageConfig.getOption('settingsUrl') ?? '/';\n        const all = (await (await fetch(URLExt.join(settingsUrl, file))).json());\n        return all;\n    }\n    _storageName = DEFAULT_STORAGE_NAME;\n    _storageDrivers = null;\n    _storage;\n    _localforage;\n    _ready;\n}\n/**\n * A namespace for private data\n */\nvar Private;\n(function (Private) {\n    const _overrides = JSON.parse(PageConfig.getOption('settingsOverrides') || '{}');\n    /**\n     * Override the defaults of the schema with ones from PageConfig\n     *\n     * @see https://github.com/jupyterlab/jupyterlab_server/blob/v2.5.2/jupyterlab_server/settings_handler.py#L216-L227\n     */\n    function override(plugin) {\n        if (_overrides[plugin.id]) {\n            if (!plugin.schema.properties) {\n                // probably malformed, or only provides keyboard shortcuts, etc.\n                plugin.schema.properties = {};\n            }\n            for (const [prop, propDefault] of Object.entries(_overrides[plugin.id] || {})) {\n                plugin.schema.properties[prop].default = propDefault;\n            }\n        }\n        return plugin;\n    }\n    Private.override = override;\n})(Private || (Private = {}));\n//# sourceMappingURL=settings.js.map","/*\n * Copyright (c) 2021-2023 Datalayer, Inc.\n *\n * MIT License\n */\nimport { Token } from '@lumino/coreutils';\n/**\n * The token for the settings service.\n */\nexport const ISettings = new Token('@jupyterlite/settings:ISettings');\n//# sourceMappingURL=tokens.js.map","/*\n * Copyright (c) 2021-2023 Datalayer, Inc.\n *\n * MIT License\n */\nimport { PageConfig, URLExt } from '@jupyterlab/coreutils';\n/**\n * A fake locale to retrieve all the language packs.\n */\nconst ALL = 'all';\n/**\n * A class to handle requests to /api/translations\n */\nexport class Translation {\n    /**\n     * Get the translation data for the given locale\n     * @param locale The locale\n     * @returns\n     */\n    async get(locale) {\n        const apiURL = URLExt.join(PageConfig.getBaseUrl(), `api/translations/${locale}.json`);\n        try {\n            const response = await fetch(apiURL);\n            const json = JSON.parse(await response.text());\n            if (this._prevLocale !== ALL && locale === ALL) {\n                // TODO: fix this logic upstream?\n                // the upstream translation plugin relies on the comparison between\n                // the display name and the native name to enable or disable the commands:\n                // https://github.com/jupyterlab/jupyterlab/blob/befa831ffef36321b87f352a48fbe2439df6c872/packages/translation-extension/src/index.ts#L117\n                const prev = this._prevLocale;\n                json.data[prev].displayName = json.data[prev].nativeName;\n                if (prev !== 'en') {\n                    json.data['en'].displayName =\n                        `${json.data['en'].nativeName} (default)`;\n                }\n            }\n            this._prevLocale = locale;\n            return json;\n        }\n        catch (e) {\n            if (locale) {\n                return {\n                    data: {},\n                    message: `Language pack '${locale}' not installed!`,\n                };\n            }\n            return {\n                data: {\n                    en: { displayName: 'English', nativeName: 'English' },\n                },\n                message: '',\n            };\n        }\n    }\n    _prevLocale = '';\n}\n//# sourceMappingURL=translation.js.map","/*\n * Copyright (c) 2021-2023 Datalayer, Inc.\n *\n * MIT License\n */\nimport { Token } from '@lumino/coreutils';\n/**\n * The token for the settings service.\n */\nexport const ITranslation = new Token('@jupyterlite/translation:ITranslation');\n//# sourceMappingURL=tokens.js.map","/*!\n    localForage -- Offline Storage, Improved\n    Version 1.10.0\n    https://localforage.github.io/localForage\n    (c) 2013-2017 Mozilla, Apache License 2.0\n*/\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.localforage = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw (f.code=\"MODULE_NOT_FOUND\", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],2:[function(_dereq_,module,exports){\n'use strict';\nvar immediate = _dereq_(1);\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n},{\"1\":1}],3:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nif (typeof global.Promise !== 'function') {\n  global.Promise = _dereq_(2);\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"2\":2}],4:[function(_dereq_,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction getIDB() {\n    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */\n    try {\n        if (typeof indexedDB !== 'undefined') {\n            return indexedDB;\n        }\n        if (typeof webkitIndexedDB !== 'undefined') {\n            return webkitIndexedDB;\n        }\n        if (typeof mozIndexedDB !== 'undefined') {\n            return mozIndexedDB;\n        }\n        if (typeof OIndexedDB !== 'undefined') {\n            return OIndexedDB;\n        }\n        if (typeof msIndexedDB !== 'undefined') {\n            return msIndexedDB;\n        }\n    } catch (e) {\n        return;\n    }\n}\n\nvar idb = getIDB();\n\nfunction isIndexedDBValid() {\n    try {\n        // Initialize IndexedDB; fall back to vendor-prefixed versions\n        // if needed.\n        if (!idb || !idb.open) {\n            return false;\n        }\n        // We mimic PouchDB here;\n        //\n        // We test for openDatabase because IE Mobile identifies itself\n        // as Safari. Oh the lulz...\n        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);\n\n        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;\n\n        // Safari <10.1 does not meet our requirements for IDB support\n        // (see: https://github.com/pouchdb/pouchdb/issues/5572).\n        // Safari 10.1 shipped with fetch, we can use that to detect it.\n        // Note: this creates issues with `window.fetch` polyfills and\n        // overrides; see:\n        // https://github.com/localForage/localForage/issues/856\n        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&\n        // some outdated implementations of IDB that appear on Samsung\n        // and HTC Android devices <4.4 are missing IDBKeyRange\n        // See: https://github.com/mozilla/localForage/issues/128\n        // See: https://github.com/mozilla/localForage/issues/272\n        typeof IDBKeyRange !== 'undefined';\n    } catch (e) {\n        return false;\n    }\n}\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\nfunction createBlob(parts, properties) {\n    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n    parts = parts || [];\n    properties = properties || {};\n    try {\n        return new Blob(parts, properties);\n    } catch (e) {\n        if (e.name !== 'TypeError') {\n            throw e;\n        }\n        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;\n        var builder = new Builder();\n        for (var i = 0; i < parts.length; i += 1) {\n            builder.append(parts[i]);\n        }\n        return builder.getBlob(properties.type);\n    }\n}\n\n// This is CommonJS because lie is an external dependency, so Rollup\n// can just ignore it.\nif (typeof Promise === 'undefined') {\n    // In the \"nopromises\" build this will just throw if you don't have\n    // a global promise object, but it would throw anyway later.\n    _dereq_(3);\n}\nvar Promise$1 = Promise;\n\nfunction executeCallback(promise, callback) {\n    if (callback) {\n        promise.then(function (result) {\n            callback(null, result);\n        }, function (error) {\n            callback(error);\n        });\n    }\n}\n\nfunction executeTwoCallbacks(promise, callback, errorCallback) {\n    if (typeof callback === 'function') {\n        promise.then(callback);\n    }\n\n    if (typeof errorCallback === 'function') {\n        promise[\"catch\"](errorCallback);\n    }\n}\n\nfunction normalizeKey(key) {\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    return key;\n}\n\nfunction getCallback() {\n    if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {\n        return arguments[arguments.length - 1];\n    }\n}\n\n// Some code originally from async_storage.js in\n// [Gaia](https://github.com/mozilla-b2g/gaia).\n\nvar DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';\nvar supportsBlobs = void 0;\nvar dbContexts = {};\nvar toString = Object.prototype.toString;\n\n// Transaction Modes\nvar READ_ONLY = 'readonly';\nvar READ_WRITE = 'readwrite';\n\n// Transform a binary string to an array buffer, because otherwise\n// weird stuff happens when you try to work with the binary string directly.\n// It is known.\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction _binStringToArrayBuffer(bin) {\n    var length = bin.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    for (var i = 0; i < length; i++) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return buf;\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\n// Code borrowed from PouchDB. See:\n// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n//\nfunction _checkBlobSupportWithoutCaching(idb) {\n    return new Promise$1(function (resolve) {\n        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);\n        var blob = createBlob(['']);\n        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\n        txn.onabort = function (e) {\n            // If the transaction aborts now its due to not being able to\n            // write to the database, likely due to the disk being full\n            e.preventDefault();\n            e.stopPropagation();\n            resolve(false);\n        };\n\n        txn.oncomplete = function () {\n            var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n            var matchedEdge = navigator.userAgent.match(/Edge\\//);\n            // MS Edge pretends to be Chrome 42:\n            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n        };\n    })[\"catch\"](function () {\n        return false; // error, so assume unsupported\n    });\n}\n\nfunction _checkBlobSupport(idb) {\n    if (typeof supportsBlobs === 'boolean') {\n        return Promise$1.resolve(supportsBlobs);\n    }\n    return _checkBlobSupportWithoutCaching(idb).then(function (value) {\n        supportsBlobs = value;\n        return supportsBlobs;\n    });\n}\n\nfunction _deferReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Create a deferred object representing the current database operation.\n    var deferredOperation = {};\n\n    deferredOperation.promise = new Promise$1(function (resolve, reject) {\n        deferredOperation.resolve = resolve;\n        deferredOperation.reject = reject;\n    });\n\n    // Enqueue the deferred operation.\n    dbContext.deferredOperations.push(deferredOperation);\n\n    // Chain its promise to the database readiness.\n    if (!dbContext.dbReady) {\n        dbContext.dbReady = deferredOperation.promise;\n    } else {\n        dbContext.dbReady = dbContext.dbReady.then(function () {\n            return deferredOperation.promise;\n        });\n    }\n}\n\nfunction _advanceReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Resolve its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.resolve();\n        return deferredOperation.promise;\n    }\n}\n\nfunction _rejectReadiness(dbInfo, err) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Reject its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.reject(err);\n        return deferredOperation.promise;\n    }\n}\n\nfunction _getConnection(dbInfo, upgradeNeeded) {\n    return new Promise$1(function (resolve, reject) {\n        dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();\n\n        if (dbInfo.db) {\n            if (upgradeNeeded) {\n                _deferReadiness(dbInfo);\n                dbInfo.db.close();\n            } else {\n                return resolve(dbInfo.db);\n            }\n        }\n\n        var dbArgs = [dbInfo.name];\n\n        if (upgradeNeeded) {\n            dbArgs.push(dbInfo.version);\n        }\n\n        var openreq = idb.open.apply(idb, dbArgs);\n\n        if (upgradeNeeded) {\n            openreq.onupgradeneeded = function (e) {\n                var db = openreq.result;\n                try {\n                    db.createObjectStore(dbInfo.storeName);\n                    if (e.oldVersion <= 1) {\n                        // Added when support for blob shims was added\n                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n                    }\n                } catch (ex) {\n                    if (ex.name === 'ConstraintError') {\n                        console.warn('The database \"' + dbInfo.name + '\"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n                    } else {\n                        throw ex;\n                    }\n                }\n            };\n        }\n\n        openreq.onerror = function (e) {\n            e.preventDefault();\n            reject(openreq.error);\n        };\n\n        openreq.onsuccess = function () {\n            var db = openreq.result;\n            db.onversionchange = function (e) {\n                // Triggered when the database is modified (e.g. adding an objectStore) or\n                // deleted (even when initiated by other sessions in different tabs).\n                // Closing the connection here prevents those operations from being blocked.\n                // If the database is accessed again later by this instance, the connection\n                // will be reopened or the database recreated as needed.\n                e.target.close();\n            };\n            resolve(db);\n            _advanceReadiness(dbInfo);\n        };\n    });\n}\n\nfunction _getOriginalConnection(dbInfo) {\n    return _getConnection(dbInfo, false);\n}\n\nfunction _getUpgradedConnection(dbInfo) {\n    return _getConnection(dbInfo, true);\n}\n\nfunction _isUpgradeNeeded(dbInfo, defaultVersion) {\n    if (!dbInfo.db) {\n        return true;\n    }\n\n    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n    var isDowngrade = dbInfo.version < dbInfo.db.version;\n    var isUpgrade = dbInfo.version > dbInfo.db.version;\n\n    if (isDowngrade) {\n        // If the version is not the default one\n        // then warn for impossible downgrade.\n        if (dbInfo.version !== defaultVersion) {\n            console.warn('The database \"' + dbInfo.name + '\"' + \" can't be downgraded from version \" + dbInfo.db.version + ' to version ' + dbInfo.version + '.');\n        }\n        // Align the versions to prevent errors.\n        dbInfo.version = dbInfo.db.version;\n    }\n\n    if (isUpgrade || isNewStore) {\n        // If the store is new then increment the version (if needed).\n        // This will trigger an \"upgradeneeded\" event which is required\n        // for creating a store.\n        if (isNewStore) {\n            var incVersion = dbInfo.db.version + 1;\n            if (incVersion > dbInfo.version) {\n                dbInfo.version = incVersion;\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n// encode a blob for indexeddb engines that don't support blobs\nfunction _encodeBlob(blob) {\n    return new Promise$1(function (resolve, reject) {\n        var reader = new FileReader();\n        reader.onerror = reject;\n        reader.onloadend = function (e) {\n            var base64 = btoa(e.target.result || '');\n            resolve({\n                __local_forage_encoded_blob: true,\n                data: base64,\n                type: blob.type\n            });\n        };\n        reader.readAsBinaryString(blob);\n    });\n}\n\n// decode an encoded blob\nfunction _decodeBlob(encodedBlob) {\n    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n    return createBlob([arrayBuff], { type: encodedBlob.type });\n}\n\n// is this one of our fancy encoded blobs?\nfunction _isEncodedBlob(value) {\n    return value && value.__local_forage_encoded_blob;\n}\n\n// Specialize the default `ready()` function by making it dependent\n// on the current database operations. Thus, the driver will be actually\n// ready when it's been initialized (default) *and* there are no pending\n// operations on the database (initiated by some other instances).\nfunction _fullyReady(callback) {\n    var self = this;\n\n    var promise = self._initReady().then(function () {\n        var dbContext = dbContexts[self._dbInfo.name];\n\n        if (dbContext && dbContext.dbReady) {\n            return dbContext.dbReady;\n        }\n    });\n\n    executeTwoCallbacks(promise, callback, callback);\n    return promise;\n}\n\n// Try to establish a new db connection to replace the\n// current one which is broken (i.e. experiencing\n// InvalidStateError while creating a transaction).\nfunction _tryReconnect(dbInfo) {\n    _deferReadiness(dbInfo);\n\n    var dbContext = dbContexts[dbInfo.name];\n    var forages = dbContext.forages;\n\n    for (var i = 0; i < forages.length; i++) {\n        var forage = forages[i];\n        if (forage._dbInfo.db) {\n            forage._dbInfo.db.close();\n            forage._dbInfo.db = null;\n        }\n    }\n    dbInfo.db = null;\n\n    return _getOriginalConnection(dbInfo).then(function (db) {\n        dbInfo.db = db;\n        if (_isUpgradeNeeded(dbInfo)) {\n            // Reopen the database for upgrading.\n            return _getUpgradedConnection(dbInfo);\n        }\n        return db;\n    }).then(function (db) {\n        // store the latest db reference\n        // in case the db was upgraded\n        dbInfo.db = dbContext.db = db;\n        for (var i = 0; i < forages.length; i++) {\n            forages[i]._dbInfo.db = db;\n        }\n    })[\"catch\"](function (err) {\n        _rejectReadiness(dbInfo, err);\n        throw err;\n    });\n}\n\n// FF doesn't like Promises (micro-tasks) and IDDB store operations,\n// so we have to do it with callbacks\nfunction createTransaction(dbInfo, mode, callback, retries) {\n    if (retries === undefined) {\n        retries = 1;\n    }\n\n    try {\n        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);\n        callback(null, tx);\n    } catch (err) {\n        if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {\n            return Promise$1.resolve().then(function () {\n                if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {\n                    // increase the db version, to create the new ObjectStore\n                    if (dbInfo.db) {\n                        dbInfo.version = dbInfo.db.version + 1;\n                    }\n                    // Reopen the database for upgrading.\n                    return _getUpgradedConnection(dbInfo);\n                }\n            }).then(function () {\n                return _tryReconnect(dbInfo).then(function () {\n                    createTransaction(dbInfo, mode, callback, retries - 1);\n                });\n            })[\"catch\"](callback);\n        }\n\n        callback(err);\n    }\n}\n\nfunction createDbContext() {\n    return {\n        // Running localForages sharing a database.\n        forages: [],\n        // Shared database.\n        db: null,\n        // Database readiness (promise).\n        dbReady: null,\n        // Deferred operations on the database.\n        deferredOperations: []\n    };\n}\n\n// Open the IndexedDB database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    // Get the current context of the database;\n    var dbContext = dbContexts[dbInfo.name];\n\n    // ...or create a new context.\n    if (!dbContext) {\n        dbContext = createDbContext();\n        // Register the new context in the global container.\n        dbContexts[dbInfo.name] = dbContext;\n    }\n\n    // Register itself as a running localForage in the current context.\n    dbContext.forages.push(self);\n\n    // Replace the default `ready()` function with the specialized one.\n    if (!self._initReady) {\n        self._initReady = self.ready;\n        self.ready = _fullyReady;\n    }\n\n    // Create an array of initialization states of the related localForages.\n    var initPromises = [];\n\n    function ignoreErrors() {\n        // Don't handle errors here,\n        // just makes sure related localForages aren't pending.\n        return Promise$1.resolve();\n    }\n\n    for (var j = 0; j < dbContext.forages.length; j++) {\n        var forage = dbContext.forages[j];\n        if (forage !== self) {\n            // Don't wait for itself...\n            initPromises.push(forage._initReady()[\"catch\"](ignoreErrors));\n        }\n    }\n\n    // Take a snapshot of the related localForages.\n    var forages = dbContext.forages.slice(0);\n\n    // Initialize the connection process only when\n    // all the related localForages aren't pending.\n    return Promise$1.all(initPromises).then(function () {\n        dbInfo.db = dbContext.db;\n        // Get the connection or open a new one without upgrade.\n        return _getOriginalConnection(dbInfo);\n    }).then(function (db) {\n        dbInfo.db = db;\n        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {\n            // Reopen the database for upgrading.\n            return _getUpgradedConnection(dbInfo);\n        }\n        return db;\n    }).then(function (db) {\n        dbInfo.db = dbContext.db = db;\n        self._dbInfo = dbInfo;\n        // Share the final connection amongst related localForages.\n        for (var k = 0; k < forages.length; k++) {\n            var forage = forages[k];\n            if (forage !== self) {\n                // Self is already up-to-date.\n                forage._dbInfo.db = dbInfo.db;\n                forage._dbInfo.version = dbInfo.version;\n            }\n        }\n    });\n}\n\nfunction getItem(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.get(key);\n\n                    req.onsuccess = function () {\n                        var value = req.result;\n                        if (value === undefined) {\n                            value = null;\n                        }\n                        if (_isEncodedBlob(value)) {\n                            value = _decodeBlob(value);\n                        }\n                        resolve(value);\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items stored in database.\nfunction iterate(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.openCursor();\n                    var iterationNumber = 1;\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n\n                        if (cursor) {\n                            var value = cursor.value;\n                            if (_isEncodedBlob(value)) {\n                                value = _decodeBlob(value);\n                            }\n                            var result = iterator(value, cursor.key, iterationNumber++);\n\n                            // when the iterator callback returns any\n                            // (non-`undefined`) value, then we stop\n                            // the iteration immediately\n                            if (result !== void 0) {\n                                resolve(result);\n                            } else {\n                                cursor[\"continue\"]();\n                            }\n                        } else {\n                            resolve();\n                        }\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n\n    return promise;\n}\n\nfunction setItem(key, value, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        var dbInfo;\n        self.ready().then(function () {\n            dbInfo = self._dbInfo;\n            if (toString.call(value) === '[object Blob]') {\n                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {\n                    if (blobSupport) {\n                        return value;\n                    }\n                    return _encodeBlob(value);\n                });\n            }\n            return value;\n        }).then(function (value) {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n\n                    // The reason we don't _save_ null is because IE 10 does\n                    // not support saving the `null` type in IndexedDB. How\n                    // ironic, given the bug below!\n                    // See: https://github.com/mozilla/localForage/issues/161\n                    if (value === null) {\n                        value = undefined;\n                    }\n\n                    var req = store.put(value, key);\n\n                    transaction.oncomplete = function () {\n                        // Cast to undefined so the value passed to\n                        // callback/promise is the same as what one would get out\n                        // of `getItem()` later. This leads to some weirdness\n                        // (setItem('foo', undefined) will return `null`), but\n                        // it's not my fault localStorage is our baseline and that\n                        // it's weird.\n                        if (value === undefined) {\n                            value = null;\n                        }\n\n                        resolve(value);\n                    };\n                    transaction.onabort = transaction.onerror = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction removeItem(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    // We use a Grunt task to make this safe for IE and some\n                    // versions of Android (including those used by Cordova).\n                    // Normally IE won't like `.delete()` and will insist on\n                    // using `['delete']()`, but we have a build step that\n                    // fixes this for us now.\n                    var req = store[\"delete\"](key);\n                    transaction.oncomplete = function () {\n                        resolve();\n                    };\n\n                    transaction.onerror = function () {\n                        reject(req.error);\n                    };\n\n                    // The request will be also be aborted if we've exceeded our storage\n                    // space.\n                    transaction.onabort = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction clear(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.clear();\n\n                    transaction.oncomplete = function () {\n                        resolve();\n                    };\n\n                    transaction.onabort = transaction.onerror = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction length(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.count();\n\n                    req.onsuccess = function () {\n                        resolve(req.result);\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction key(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        if (n < 0) {\n            resolve(null);\n\n            return;\n        }\n\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var advanced = false;\n                    var req = store.openKeyCursor();\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n                        if (!cursor) {\n                            // this means there weren't enough keys\n                            resolve(null);\n\n                            return;\n                        }\n\n                        if (n === 0) {\n                            // We have the first key, return it if that's what they\n                            // wanted.\n                            resolve(cursor.key);\n                        } else {\n                            if (!advanced) {\n                                // Otherwise, ask the cursor to skip ahead n\n                                // records.\n                                advanced = true;\n                                cursor.advance(n);\n                            } else {\n                                // When we get here, we've got the nth key.\n                                resolve(cursor.key);\n                            }\n                        }\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.openKeyCursor();\n                    var keys = [];\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n\n                        if (!cursor) {\n                            resolve(keys);\n                            return;\n                        }\n\n                        keys.push(cursor.key);\n                        cursor[\"continue\"]();\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction dropInstance(options, callback) {\n    callback = getCallback.apply(this, arguments);\n\n    var currentConfig = this.config();\n    options = typeof options !== 'function' && options || {};\n    if (!options.name) {\n        options.name = options.name || currentConfig.name;\n        options.storeName = options.storeName || currentConfig.storeName;\n    }\n\n    var self = this;\n    var promise;\n    if (!options.name) {\n        promise = Promise$1.reject('Invalid arguments');\n    } else {\n        var isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;\n\n        var dbPromise = isCurrentDb ? Promise$1.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(function (db) {\n            var dbContext = dbContexts[options.name];\n            var forages = dbContext.forages;\n            dbContext.db = db;\n            for (var i = 0; i < forages.length; i++) {\n                forages[i]._dbInfo.db = db;\n            }\n            return db;\n        });\n\n        if (!options.storeName) {\n            promise = dbPromise.then(function (db) {\n                _deferReadiness(options);\n\n                var dbContext = dbContexts[options.name];\n                var forages = dbContext.forages;\n\n                db.close();\n                for (var i = 0; i < forages.length; i++) {\n                    var forage = forages[i];\n                    forage._dbInfo.db = null;\n                }\n\n                var dropDBPromise = new Promise$1(function (resolve, reject) {\n                    var req = idb.deleteDatabase(options.name);\n\n                    req.onerror = function () {\n                        var db = req.result;\n                        if (db) {\n                            db.close();\n                        }\n                        reject(req.error);\n                    };\n\n                    req.onblocked = function () {\n                        // Closing all open connections in onversionchange handler should prevent this situation, but if\n                        // we do get here, it just means the request remains pending - eventually it will succeed or error\n                        console.warn('dropInstance blocked for database \"' + options.name + '\" until all open connections are closed');\n                    };\n\n                    req.onsuccess = function () {\n                        var db = req.result;\n                        if (db) {\n                            db.close();\n                        }\n                        resolve(db);\n                    };\n                });\n\n                return dropDBPromise.then(function (db) {\n                    dbContext.db = db;\n                    for (var i = 0; i < forages.length; i++) {\n                        var _forage = forages[i];\n                        _advanceReadiness(_forage._dbInfo);\n                    }\n                })[\"catch\"](function (err) {\n                    (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function () {});\n                    throw err;\n                });\n            });\n        } else {\n            promise = dbPromise.then(function (db) {\n                if (!db.objectStoreNames.contains(options.storeName)) {\n                    return;\n                }\n\n                var newVersion = db.version + 1;\n\n                _deferReadiness(options);\n\n                var dbContext = dbContexts[options.name];\n                var forages = dbContext.forages;\n\n                db.close();\n                for (var i = 0; i < forages.length; i++) {\n                    var forage = forages[i];\n                    forage._dbInfo.db = null;\n                    forage._dbInfo.version = newVersion;\n                }\n\n                var dropObjectPromise = new Promise$1(function (resolve, reject) {\n                    var req = idb.open(options.name, newVersion);\n\n                    req.onerror = function (err) {\n                        var db = req.result;\n                        db.close();\n                        reject(err);\n                    };\n\n                    req.onupgradeneeded = function () {\n                        var db = req.result;\n                        db.deleteObjectStore(options.storeName);\n                    };\n\n                    req.onsuccess = function () {\n                        var db = req.result;\n                        db.close();\n                        resolve(db);\n                    };\n                });\n\n                return dropObjectPromise.then(function (db) {\n                    dbContext.db = db;\n                    for (var j = 0; j < forages.length; j++) {\n                        var _forage2 = forages[j];\n                        _forage2._dbInfo.db = db;\n                        _advanceReadiness(_forage2._dbInfo);\n                    }\n                })[\"catch\"](function (err) {\n                    (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function () {});\n                    throw err;\n                });\n            });\n        }\n    }\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar asyncStorage = {\n    _driver: 'asyncStorage',\n    _initStorage: _initStorage,\n    _support: isIndexedDBValid(),\n    iterate: iterate,\n    getItem: getItem,\n    setItem: setItem,\n    removeItem: removeItem,\n    clear: clear,\n    length: length,\n    key: key,\n    keys: keys,\n    dropInstance: dropInstance\n};\n\nfunction isWebSQLValid() {\n    return typeof openDatabase === 'function';\n}\n\n// Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n// it to Base64, so this is how we store it to prevent very strange errors with less\n// verbose ways of binary <-> string data storage.\nvar BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nvar BLOB_TYPE_PREFIX = '~~local_forage_type~';\nvar BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n\nvar SERIALIZED_MARKER = '__lfsc__:';\nvar SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n\n// OMG the serializations!\nvar TYPE_ARRAYBUFFER = 'arbf';\nvar TYPE_BLOB = 'blob';\nvar TYPE_INT8ARRAY = 'si08';\nvar TYPE_UINT8ARRAY = 'ui08';\nvar TYPE_UINT8CLAMPEDARRAY = 'uic8';\nvar TYPE_INT16ARRAY = 'si16';\nvar TYPE_INT32ARRAY = 'si32';\nvar TYPE_UINT16ARRAY = 'ur16';\nvar TYPE_UINT32ARRAY = 'ui32';\nvar TYPE_FLOAT32ARRAY = 'fl32';\nvar TYPE_FLOAT64ARRAY = 'fl64';\nvar TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n\nvar toString$1 = Object.prototype.toString;\n\nfunction stringToBuffer(serializedString) {\n    // Fill the string into a ArrayBuffer.\n    var bufferLength = serializedString.length * 0.75;\n    var len = serializedString.length;\n    var i;\n    var p = 0;\n    var encoded1, encoded2, encoded3, encoded4;\n\n    if (serializedString[serializedString.length - 1] === '=') {\n        bufferLength--;\n        if (serializedString[serializedString.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n\n    var buffer = new ArrayBuffer(bufferLength);\n    var bytes = new Uint8Array(buffer);\n\n    for (i = 0; i < len; i += 4) {\n        encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n\n        /*jslint bitwise: true */\n        bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n    }\n    return buffer;\n}\n\n// Converts a buffer to a string to store, serialized, in the backend\n// storage library.\nfunction bufferToString(buffer) {\n    // base64-arraybuffer\n    var bytes = new Uint8Array(buffer);\n    var base64String = '';\n    var i;\n\n    for (i = 0; i < bytes.length; i += 3) {\n        /*jslint bitwise: true */\n        base64String += BASE_CHARS[bytes[i] >> 2];\n        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n        base64String += BASE_CHARS[bytes[i + 2] & 63];\n    }\n\n    if (bytes.length % 3 === 2) {\n        base64String = base64String.substring(0, base64String.length - 1) + '=';\n    } else if (bytes.length % 3 === 1) {\n        base64String = base64String.substring(0, base64String.length - 2) + '==';\n    }\n\n    return base64String;\n}\n\n// Serialize a value, afterwards executing a callback (which usually\n// instructs the `setItem()` callback/promise to be executed). This is how\n// we store binary data with localStorage.\nfunction serialize(value, callback) {\n    var valueType = '';\n    if (value) {\n        valueType = toString$1.call(value);\n    }\n\n    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n    // checks fail when running the tests using casper.js...\n    //\n    // TODO: See why those tests fail and use a better solution.\n    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {\n        // Convert binary arrays to a string and prefix the string with\n        // a special marker.\n        var buffer;\n        var marker = SERIALIZED_MARKER;\n\n        if (value instanceof ArrayBuffer) {\n            buffer = value;\n            marker += TYPE_ARRAYBUFFER;\n        } else {\n            buffer = value.buffer;\n\n            if (valueType === '[object Int8Array]') {\n                marker += TYPE_INT8ARRAY;\n            } else if (valueType === '[object Uint8Array]') {\n                marker += TYPE_UINT8ARRAY;\n            } else if (valueType === '[object Uint8ClampedArray]') {\n                marker += TYPE_UINT8CLAMPEDARRAY;\n            } else if (valueType === '[object Int16Array]') {\n                marker += TYPE_INT16ARRAY;\n            } else if (valueType === '[object Uint16Array]') {\n                marker += TYPE_UINT16ARRAY;\n            } else if (valueType === '[object Int32Array]') {\n                marker += TYPE_INT32ARRAY;\n            } else if (valueType === '[object Uint32Array]') {\n                marker += TYPE_UINT32ARRAY;\n            } else if (valueType === '[object Float32Array]') {\n                marker += TYPE_FLOAT32ARRAY;\n            } else if (valueType === '[object Float64Array]') {\n                marker += TYPE_FLOAT64ARRAY;\n            } else {\n                callback(new Error('Failed to get type for BinaryArray'));\n            }\n        }\n\n        callback(marker + bufferToString(buffer));\n    } else if (valueType === '[object Blob]') {\n        // Conver the blob to a binaryArray and then to a string.\n        var fileReader = new FileReader();\n\n        fileReader.onload = function () {\n            // Backwards-compatible prefix for the blob type.\n            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);\n\n            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n        };\n\n        fileReader.readAsArrayBuffer(value);\n    } else {\n        try {\n            callback(JSON.stringify(value));\n        } catch (e) {\n            console.error(\"Couldn't convert value into a JSON string: \", value);\n\n            callback(null, e);\n        }\n    }\n}\n\n// Deserialize data we've inserted into a value column/field. We place\n// special markers into our strings to mark them as encoded; this isn't\n// as nice as a meta field, but it's the only sane thing we can do whilst\n// keeping localStorage support intact.\n//\n// Oftentimes this will just deserialize JSON content, but if we have a\n// special marker (SERIALIZED_MARKER, defined above), we will extract\n// some kind of arraybuffer/binary data/typed array out of the string.\nfunction deserialize(value) {\n    // If we haven't marked this string as being specially serialized (i.e.\n    // something other than serialized JSON), we can just return it and be\n    // done with it.\n    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n        return JSON.parse(value);\n    }\n\n    // The following code deals with deserializing some kind of Blob or\n    // TypedArray. First we separate out the type of data we're dealing\n    // with from the data itself.\n    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n\n    var blobType;\n    // Backwards-compatible blob type serialization strategy.\n    // DBs created with older versions of localForage will simply not have the blob type.\n    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n        blobType = matcher[1];\n        serializedString = serializedString.substring(matcher[0].length);\n    }\n    var buffer = stringToBuffer(serializedString);\n\n    // Return the right type based on the code/type set during\n    // serialization.\n    switch (type) {\n        case TYPE_ARRAYBUFFER:\n            return buffer;\n        case TYPE_BLOB:\n            return createBlob([buffer], { type: blobType });\n        case TYPE_INT8ARRAY:\n            return new Int8Array(buffer);\n        case TYPE_UINT8ARRAY:\n            return new Uint8Array(buffer);\n        case TYPE_UINT8CLAMPEDARRAY:\n            return new Uint8ClampedArray(buffer);\n        case TYPE_INT16ARRAY:\n            return new Int16Array(buffer);\n        case TYPE_UINT16ARRAY:\n            return new Uint16Array(buffer);\n        case TYPE_INT32ARRAY:\n            return new Int32Array(buffer);\n        case TYPE_UINT32ARRAY:\n            return new Uint32Array(buffer);\n        case TYPE_FLOAT32ARRAY:\n            return new Float32Array(buffer);\n        case TYPE_FLOAT64ARRAY:\n            return new Float64Array(buffer);\n        default:\n            throw new Error('Unkown type: ' + type);\n    }\n}\n\nvar localforageSerializer = {\n    serialize: serialize,\n    deserialize: deserialize,\n    stringToBuffer: stringToBuffer,\n    bufferToString: bufferToString\n};\n\n/*\n * Includes code from:\n *\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n\nfunction createDbTable(t, dbInfo, callback, errorCallback) {\n    t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' ' + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);\n}\n\n// Open the WebSQL database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage$1(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];\n        }\n    }\n\n    var dbInfoPromise = new Promise$1(function (resolve, reject) {\n        // Open the database; the openDatabase API will automatically\n        // create it for us if it doesn't exist.\n        try {\n            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n        } catch (e) {\n            return reject(e);\n        }\n\n        // Create our key/value table if it doesn't exist.\n        dbInfo.db.transaction(function (t) {\n            createDbTable(t, dbInfo, function () {\n                self._dbInfo = dbInfo;\n                resolve();\n            }, function (t, error) {\n                reject(error);\n            });\n        }, reject);\n    });\n\n    dbInfo.serializer = localforageSerializer;\n    return dbInfoPromise;\n}\n\nfunction tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {\n    t.executeSql(sqlStatement, args, callback, function (t, error) {\n        if (error.code === error.SYNTAX_ERR) {\n            t.executeSql('SELECT name FROM sqlite_master ' + \"WHERE type='table' AND name = ?\", [dbInfo.storeName], function (t, results) {\n                if (!results.rows.length) {\n                    // if the table is missing (was deleted)\n                    // re-create it table and retry\n                    createDbTable(t, dbInfo, function () {\n                        t.executeSql(sqlStatement, args, callback, errorCallback);\n                    }, errorCallback);\n                } else {\n                    errorCallback(t, error);\n                }\n            }, errorCallback);\n        } else {\n            errorCallback(t, error);\n        }\n    }, errorCallback);\n}\n\nfunction getItem$1(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).value : null;\n\n                    // Check to see if this is serialized content we need to\n                    // unpack.\n                    if (result) {\n                        result = dbInfo.serializer.deserialize(result);\n                    }\n\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction iterate$1(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var rows = results.rows;\n                    var length = rows.length;\n\n                    for (var i = 0; i < length; i++) {\n                        var item = rows.item(i);\n                        var result = item.value;\n\n                        // Check to see if this is serialized content\n                        // we need to unpack.\n                        if (result) {\n                            result = dbInfo.serializer.deserialize(result);\n                        }\n\n                        result = iterator(result, item.key, i + 1);\n\n                        // void(0) prevents problems with redefinition\n                        // of `undefined`.\n                        if (result !== void 0) {\n                            resolve(result);\n                            return;\n                        }\n                    }\n\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction _setItem(key, value, callback, retriesLeft) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            // The localStorage API doesn't return undefined values in an\n            // \"expected\" way, so undefined is always cast to null in all\n            // drivers. See: https://github.com/mozilla/localForage/pull/42\n            if (value === undefined) {\n                value = null;\n            }\n\n            // Save the original value to pass to the callback.\n            var originalValue = value;\n\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    dbInfo.db.transaction(function (t) {\n                        tryExecuteSql(t, dbInfo, 'INSERT OR REPLACE INTO ' + dbInfo.storeName + ' ' + '(key, value) VALUES (?, ?)', [key, value], function () {\n                            resolve(originalValue);\n                        }, function (t, error) {\n                            reject(error);\n                        });\n                    }, function (sqlError) {\n                        // The transaction failed; check\n                        // to see if it's a quota error.\n                        if (sqlError.code === sqlError.QUOTA_ERR) {\n                            // We reject the callback outright for now, but\n                            // it's worth trying to re-run the transaction.\n                            // Even if the user accepts the prompt to use\n                            // more storage on Safari, this error will\n                            // be called.\n                            //\n                            // Try to re-run the transaction.\n                            if (retriesLeft > 0) {\n                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));\n                                return;\n                            }\n                            reject(sqlError);\n                        }\n                    });\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction setItem$1(key, value, callback) {\n    return _setItem.apply(this, [key, value, callback, 1]);\n}\n\nfunction removeItem$1(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Deletes every item in the table.\n// TODO: Find out if this resets the AUTO_INCREMENT number.\nfunction clear$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName, [], function () {\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Does a simple `COUNT(key)` to get the number of items stored in\n// localForage.\nfunction length$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                // Ahhh, SQL makes this one soooooo easy.\n                tryExecuteSql(t, dbInfo, 'SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var result = results.rows.item(0).c;\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Return the key located at key index X; essentially gets the key from a\n// `WHERE id = ?`. This is the most efficient way I can think to implement\n// this rarely-used (in my experience) part of the API, but it can seem\n// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n// the ID of each key will change every time it's updated. Perhaps a stored\n// procedure for the `setItem()` SQL would solve this problem?\n// TODO: Don't change ID on `setItem()`.\nfunction key$1(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).key : null;\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var keys = [];\n\n                    for (var i = 0; i < results.rows.length; i++) {\n                        keys.push(results.rows.item(i).key);\n                    }\n\n                    resolve(keys);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// https://www.w3.org/TR/webdatabase/#databases\n// > There is no way to enumerate or delete the databases available for an origin from this API.\nfunction getAllStoreNames(db) {\n    return new Promise$1(function (resolve, reject) {\n        db.transaction(function (t) {\n            t.executeSql('SELECT name FROM sqlite_master ' + \"WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'\", [], function (t, results) {\n                var storeNames = [];\n\n                for (var i = 0; i < results.rows.length; i++) {\n                    storeNames.push(results.rows.item(i).name);\n                }\n\n                resolve({\n                    db: db,\n                    storeNames: storeNames\n                });\n            }, function (t, error) {\n                reject(error);\n            });\n        }, function (sqlError) {\n            reject(sqlError);\n        });\n    });\n}\n\nfunction dropInstance$1(options, callback) {\n    callback = getCallback.apply(this, arguments);\n\n    var currentConfig = this.config();\n    options = typeof options !== 'function' && options || {};\n    if (!options.name) {\n        options.name = options.name || currentConfig.name;\n        options.storeName = options.storeName || currentConfig.storeName;\n    }\n\n    var self = this;\n    var promise;\n    if (!options.name) {\n        promise = Promise$1.reject('Invalid arguments');\n    } else {\n        promise = new Promise$1(function (resolve) {\n            var db;\n            if (options.name === currentConfig.name) {\n                // use the db reference of the current instance\n                db = self._dbInfo.db;\n            } else {\n                db = openDatabase(options.name, '', '', 0);\n            }\n\n            if (!options.storeName) {\n                // drop all database tables\n                resolve(getAllStoreNames(db));\n            } else {\n                resolve({\n                    db: db,\n                    storeNames: [options.storeName]\n                });\n            }\n        }).then(function (operationInfo) {\n            return new Promise$1(function (resolve, reject) {\n                operationInfo.db.transaction(function (t) {\n                    function dropTable(storeName) {\n                        return new Promise$1(function (resolve, reject) {\n                            t.executeSql('DROP TABLE IF EXISTS ' + storeName, [], function () {\n                                resolve();\n                            }, function (t, error) {\n                                reject(error);\n                            });\n                        });\n                    }\n\n                    var operations = [];\n                    for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {\n                        operations.push(dropTable(operationInfo.storeNames[i]));\n                    }\n\n                    Promise$1.all(operations).then(function () {\n                        resolve();\n                    })[\"catch\"](function (e) {\n                        reject(e);\n                    });\n                }, function (sqlError) {\n                    reject(sqlError);\n                });\n            });\n        });\n    }\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar webSQLStorage = {\n    _driver: 'webSQLStorage',\n    _initStorage: _initStorage$1,\n    _support: isWebSQLValid(),\n    iterate: iterate$1,\n    getItem: getItem$1,\n    setItem: setItem$1,\n    removeItem: removeItem$1,\n    clear: clear$1,\n    length: length$1,\n    key: key$1,\n    keys: keys$1,\n    dropInstance: dropInstance$1\n};\n\nfunction isLocalStorageValid() {\n    try {\n        return typeof localStorage !== 'undefined' && 'setItem' in localStorage &&\n        // in IE8 typeof localStorage.setItem === 'object'\n        !!localStorage.setItem;\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction _getKeyPrefix(options, defaultConfig) {\n    var keyPrefix = options.name + '/';\n\n    if (options.storeName !== defaultConfig.storeName) {\n        keyPrefix += options.storeName + '/';\n    }\n    return keyPrefix;\n}\n\n// Check if localStorage throws when saving an item\nfunction checkIfLocalStorageThrows() {\n    var localStorageTestKey = '_localforage_support_test';\n\n    try {\n        localStorage.setItem(localStorageTestKey, true);\n        localStorage.removeItem(localStorageTestKey);\n\n        return false;\n    } catch (e) {\n        return true;\n    }\n}\n\n// Check if localStorage is usable and allows to save an item\n// This method checks if localStorage is usable in Safari Private Browsing\n// mode, or in any other case where the available quota for localStorage\n// is 0 and there wasn't any saved items yet.\nfunction _isLocalStorageUsable() {\n    return !checkIfLocalStorageThrows() || localStorage.length > 0;\n}\n\n// Config the localStorage backend, using options set in the config.\nfunction _initStorage$2(options) {\n    var self = this;\n    var dbInfo = {};\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);\n\n    if (!_isLocalStorageUsable()) {\n        return Promise$1.reject();\n    }\n\n    self._dbInfo = dbInfo;\n    dbInfo.serializer = localforageSerializer;\n\n    return Promise$1.resolve();\n}\n\n// Remove all keys from the datastore, effectively destroying all data in\n// the app's key/value store!\nfunction clear$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var keyPrefix = self._dbInfo.keyPrefix;\n\n        for (var i = localStorage.length - 1; i >= 0; i--) {\n            var key = localStorage.key(i);\n\n            if (key.indexOf(keyPrefix) === 0) {\n                localStorage.removeItem(key);\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Retrieve an item from the store. Unlike the original async_storage\n// library in Gaia, we don't modify return values at all. If a key's value\n// is `undefined`, we pass that value to the callback function.\nfunction getItem$2(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result = localStorage.getItem(dbInfo.keyPrefix + key);\n\n        // If a result was found, parse it from the serialized\n        // string into a JS object. If result isn't truthy, the key\n        // is likely undefined and we'll pass it straight to the\n        // callback.\n        if (result) {\n            result = dbInfo.serializer.deserialize(result);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items in the store.\nfunction iterate$2(iterator, callback) {\n    var self = this;\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var keyPrefix = dbInfo.keyPrefix;\n        var keyPrefixLength = keyPrefix.length;\n        var length = localStorage.length;\n\n        // We use a dedicated iterator instead of the `i` variable below\n        // so other keys we fetch in localStorage aren't counted in\n        // the `iterationNumber` argument passed to the `iterate()`\n        // callback.\n        //\n        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n        var iterationNumber = 1;\n\n        for (var i = 0; i < length; i++) {\n            var key = localStorage.key(i);\n            if (key.indexOf(keyPrefix) !== 0) {\n                continue;\n            }\n            var value = localStorage.getItem(key);\n\n            // If a result was found, parse it from the serialized\n            // string into a JS object. If result isn't truthy, the\n            // key is likely undefined and we'll pass it straight\n            // to the iterator.\n            if (value) {\n                value = dbInfo.serializer.deserialize(value);\n            }\n\n            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\n\n            if (value !== void 0) {\n                return value;\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Same as localStorage's key() method, except takes a callback.\nfunction key$2(n, callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result;\n        try {\n            result = localStorage.key(n);\n        } catch (error) {\n            result = null;\n        }\n\n        // Remove the prefix from the key, if a key is found.\n        if (result) {\n            result = result.substring(dbInfo.keyPrefix.length);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var length = localStorage.length;\n        var keys = [];\n\n        for (var i = 0; i < length; i++) {\n            var itemKey = localStorage.key(i);\n            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {\n                keys.push(itemKey.substring(dbInfo.keyPrefix.length));\n            }\n        }\n\n        return keys;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Supply the number of keys in the datastore to the callback function.\nfunction length$2(callback) {\n    var self = this;\n    var promise = self.keys().then(function (keys) {\n        return keys.length;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Remove an item from the store, nice and simple.\nfunction removeItem$2(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        localStorage.removeItem(dbInfo.keyPrefix + key);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Set a key's value and run an optional callback once the value is set.\n// Unlike Gaia's implementation, the callback function is passed the value,\n// in case you want to operate on that value only after you're sure it\n// saved, or something like that.\nfunction setItem$2(key, value, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        // Convert undefined values to null.\n        // https://github.com/mozilla/localForage/pull/42\n        if (value === undefined) {\n            value = null;\n        }\n\n        // Save the original value to pass to the callback.\n        var originalValue = value;\n\n        return new Promise$1(function (resolve, reject) {\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    try {\n                        localStorage.setItem(dbInfo.keyPrefix + key, value);\n                        resolve(originalValue);\n                    } catch (e) {\n                        // localStorage capacity exceeded.\n                        // TODO: Make this a specific error/event.\n                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n                            reject(e);\n                        }\n                        reject(e);\n                    }\n                }\n            });\n        });\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction dropInstance$2(options, callback) {\n    callback = getCallback.apply(this, arguments);\n\n    options = typeof options !== 'function' && options || {};\n    if (!options.name) {\n        var currentConfig = this.config();\n        options.name = options.name || currentConfig.name;\n        options.storeName = options.storeName || currentConfig.storeName;\n    }\n\n    var self = this;\n    var promise;\n    if (!options.name) {\n        promise = Promise$1.reject('Invalid arguments');\n    } else {\n        promise = new Promise$1(function (resolve) {\n            if (!options.storeName) {\n                resolve(options.name + '/');\n            } else {\n                resolve(_getKeyPrefix(options, self._defaultConfig));\n            }\n        }).then(function (keyPrefix) {\n            for (var i = localStorage.length - 1; i >= 0; i--) {\n                var key = localStorage.key(i);\n\n                if (key.indexOf(keyPrefix) === 0) {\n                    localStorage.removeItem(key);\n                }\n            }\n        });\n    }\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar localStorageWrapper = {\n    _driver: 'localStorageWrapper',\n    _initStorage: _initStorage$2,\n    _support: isLocalStorageValid(),\n    iterate: iterate$2,\n    getItem: getItem$2,\n    setItem: setItem$2,\n    removeItem: removeItem$2,\n    clear: clear$2,\n    length: length$2,\n    key: key$2,\n    keys: keys$2,\n    dropInstance: dropInstance$2\n};\n\nvar sameValue = function sameValue(x, y) {\n    return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);\n};\n\nvar includes = function includes(array, searchElement) {\n    var len = array.length;\n    var i = 0;\n    while (i < len) {\n        if (sameValue(array[i], searchElement)) {\n            return true;\n        }\n        i++;\n    }\n\n    return false;\n};\n\nvar isArray = Array.isArray || function (arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]';\n};\n\n// Drivers are stored here when `defineDriver()` is called.\n// They are shared across all instances of localForage.\nvar DefinedDrivers = {};\n\nvar DriverSupport = {};\n\nvar DefaultDrivers = {\n    INDEXEDDB: asyncStorage,\n    WEBSQL: webSQLStorage,\n    LOCALSTORAGE: localStorageWrapper\n};\n\nvar DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];\n\nvar OptionalDriverMethods = ['dropInstance'];\n\nvar LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(OptionalDriverMethods);\n\nvar DefaultConfig = {\n    description: '',\n    driver: DefaultDriverOrder.slice(),\n    name: 'localforage',\n    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n    // we can use without a prompt.\n    size: 4980736,\n    storeName: 'keyvaluepairs',\n    version: 1.0\n};\n\nfunction callWhenReady(localForageInstance, libraryMethod) {\n    localForageInstance[libraryMethod] = function () {\n        var _args = arguments;\n        return localForageInstance.ready().then(function () {\n            return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n        });\n    };\n}\n\nfunction extend() {\n    for (var i = 1; i < arguments.length; i++) {\n        var arg = arguments[i];\n\n        if (arg) {\n            for (var _key in arg) {\n                if (arg.hasOwnProperty(_key)) {\n                    if (isArray(arg[_key])) {\n                        arguments[0][_key] = arg[_key].slice();\n                    } else {\n                        arguments[0][_key] = arg[_key];\n                    }\n                }\n            }\n        }\n    }\n\n    return arguments[0];\n}\n\nvar LocalForage = function () {\n    function LocalForage(options) {\n        _classCallCheck(this, LocalForage);\n\n        for (var driverTypeKey in DefaultDrivers) {\n            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {\n                var driver = DefaultDrivers[driverTypeKey];\n                var driverName = driver._driver;\n                this[driverTypeKey] = driverName;\n\n                if (!DefinedDrivers[driverName]) {\n                    // we don't need to wait for the promise,\n                    // since the default drivers can be defined\n                    // in a blocking manner\n                    this.defineDriver(driver);\n                }\n            }\n        }\n\n        this._defaultConfig = extend({}, DefaultConfig);\n        this._config = extend({}, this._defaultConfig, options);\n        this._driverSet = null;\n        this._initDriver = null;\n        this._ready = false;\n        this._dbInfo = null;\n\n        this._wrapLibraryMethodsWithReady();\n        this.setDriver(this._config.driver)[\"catch\"](function () {});\n    }\n\n    // Set any config values for localForage; can be called anytime before\n    // the first API call (e.g. `getItem`, `setItem`).\n    // We loop through options so we don't overwrite existing config\n    // values.\n\n\n    LocalForage.prototype.config = function config(options) {\n        // If the options argument is an object, we use it to set values.\n        // Otherwise, we return either a specified config value or all\n        // config values.\n        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n            // If localforage is ready and fully initialized, we can't set\n            // any new configuration values. Instead, we return an error.\n            if (this._ready) {\n                return new Error(\"Can't call config() after localforage \" + 'has been used.');\n            }\n\n            for (var i in options) {\n                if (i === 'storeName') {\n                    options[i] = options[i].replace(/\\W/g, '_');\n                }\n\n                if (i === 'version' && typeof options[i] !== 'number') {\n                    return new Error('Database version must be a number.');\n                }\n\n                this._config[i] = options[i];\n            }\n\n            // after all config options are set and\n            // the driver option is used, try setting it\n            if ('driver' in options && options.driver) {\n                return this.setDriver(this._config.driver);\n            }\n\n            return true;\n        } else if (typeof options === 'string') {\n            return this._config[options];\n        } else {\n            return this._config;\n        }\n    };\n\n    // Used to define a custom driver, shared across all instances of\n    // localForage.\n\n\n    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {\n        var promise = new Promise$1(function (resolve, reject) {\n            try {\n                var driverName = driverObject._driver;\n                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');\n\n                // A driver name should be defined and not overlap with the\n                // library-defined, default drivers.\n                if (!driverObject._driver) {\n                    reject(complianceError);\n                    return;\n                }\n\n                var driverMethods = LibraryMethods.concat('_initStorage');\n                for (var i = 0, len = driverMethods.length; i < len; i++) {\n                    var driverMethodName = driverMethods[i];\n\n                    // when the property is there,\n                    // it should be a method even when optional\n                    var isRequired = !includes(OptionalDriverMethods, driverMethodName);\n                    if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {\n                        reject(complianceError);\n                        return;\n                    }\n                }\n\n                var configureMissingMethods = function configureMissingMethods() {\n                    var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {\n                        return function () {\n                            var error = new Error('Method ' + methodName + ' is not implemented by the current driver');\n                            var promise = Promise$1.reject(error);\n                            executeCallback(promise, arguments[arguments.length - 1]);\n                            return promise;\n                        };\n                    };\n\n                    for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {\n                        var optionalDriverMethod = OptionalDriverMethods[_i];\n                        if (!driverObject[optionalDriverMethod]) {\n                            driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);\n                        }\n                    }\n                };\n\n                configureMissingMethods();\n\n                var setDriverSupport = function setDriverSupport(support) {\n                    if (DefinedDrivers[driverName]) {\n                        console.info('Redefining LocalForage driver: ' + driverName);\n                    }\n                    DefinedDrivers[driverName] = driverObject;\n                    DriverSupport[driverName] = support;\n                    // don't use a then, so that we can define\n                    // drivers that have simple _support methods\n                    // in a blocking manner\n                    resolve();\n                };\n\n                if ('_support' in driverObject) {\n                    if (driverObject._support && typeof driverObject._support === 'function') {\n                        driverObject._support().then(setDriverSupport, reject);\n                    } else {\n                        setDriverSupport(!!driverObject._support);\n                    }\n                } else {\n                    setDriverSupport(true);\n                }\n            } catch (e) {\n                reject(e);\n            }\n        });\n\n        executeTwoCallbacks(promise, callback, errorCallback);\n        return promise;\n    };\n\n    LocalForage.prototype.driver = function driver() {\n        return this._driver || null;\n    };\n\n    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {\n        var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));\n\n        executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n        return getDriverPromise;\n    };\n\n    LocalForage.prototype.getSerializer = function getSerializer(callback) {\n        var serializerPromise = Promise$1.resolve(localforageSerializer);\n        executeTwoCallbacks(serializerPromise, callback);\n        return serializerPromise;\n    };\n\n    LocalForage.prototype.ready = function ready(callback) {\n        var self = this;\n\n        var promise = self._driverSet.then(function () {\n            if (self._ready === null) {\n                self._ready = self._initDriver();\n            }\n\n            return self._ready;\n        });\n\n        executeTwoCallbacks(promise, callback, callback);\n        return promise;\n    };\n\n    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {\n        var self = this;\n\n        if (!isArray(drivers)) {\n            drivers = [drivers];\n        }\n\n        var supportedDrivers = this._getSupportedDrivers(drivers);\n\n        function setDriverToConfig() {\n            self._config.driver = self.driver();\n        }\n\n        function extendSelfWithDriver(driver) {\n            self._extend(driver);\n            setDriverToConfig();\n\n            self._ready = self._initStorage(self._config);\n            return self._ready;\n        }\n\n        function initDriver(supportedDrivers) {\n            return function () {\n                var currentDriverIndex = 0;\n\n                function driverPromiseLoop() {\n                    while (currentDriverIndex < supportedDrivers.length) {\n                        var driverName = supportedDrivers[currentDriverIndex];\n                        currentDriverIndex++;\n\n                        self._dbInfo = null;\n                        self._ready = null;\n\n                        return self.getDriver(driverName).then(extendSelfWithDriver)[\"catch\"](driverPromiseLoop);\n                    }\n\n                    setDriverToConfig();\n                    var error = new Error('No available storage method found.');\n                    self._driverSet = Promise$1.reject(error);\n                    return self._driverSet;\n                }\n\n                return driverPromiseLoop();\n            };\n        }\n\n        // There might be a driver initialization in progress\n        // so wait for it to finish in order to avoid a possible\n        // race condition to set _dbInfo\n        var oldDriverSetDone = this._driverSet !== null ? this._driverSet[\"catch\"](function () {\n            return Promise$1.resolve();\n        }) : Promise$1.resolve();\n\n        this._driverSet = oldDriverSetDone.then(function () {\n            var driverName = supportedDrivers[0];\n            self._dbInfo = null;\n            self._ready = null;\n\n            return self.getDriver(driverName).then(function (driver) {\n                self._driver = driver._driver;\n                setDriverToConfig();\n                self._wrapLibraryMethodsWithReady();\n                self._initDriver = initDriver(supportedDrivers);\n            });\n        })[\"catch\"](function () {\n            setDriverToConfig();\n            var error = new Error('No available storage method found.');\n            self._driverSet = Promise$1.reject(error);\n            return self._driverSet;\n        });\n\n        executeTwoCallbacks(this._driverSet, callback, errorCallback);\n        return this._driverSet;\n    };\n\n    LocalForage.prototype.supports = function supports(driverName) {\n        return !!DriverSupport[driverName];\n    };\n\n    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {\n        extend(this, libraryMethodsAndProperties);\n    };\n\n    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {\n        var supportedDrivers = [];\n        for (var i = 0, len = drivers.length; i < len; i++) {\n            var driverName = drivers[i];\n            if (this.supports(driverName)) {\n                supportedDrivers.push(driverName);\n            }\n        }\n        return supportedDrivers;\n    };\n\n    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {\n        // Add a stub for each driver API method that delays the call to the\n        // corresponding driver method until localForage is ready. These stubs\n        // will be replaced by the driver methods as soon as the driver is\n        // loaded, so there is no performance impact.\n        for (var i = 0, len = LibraryMethods.length; i < len; i++) {\n            callWhenReady(this, LibraryMethods[i]);\n        }\n    };\n\n    LocalForage.prototype.createInstance = function createInstance(options) {\n        return new LocalForage(options);\n    };\n\n    return LocalForage;\n}();\n\n// The actual localForage object that we expose as a module or via a\n// global. It's extended by pulling in one of our other libraries.\n\n\nvar localforage_js = new LocalForage();\n\nmodule.exports = localforage_js;\n\n},{\"3\":3}]},{},[4])(4)\n});\n","/*\n * Copyright (c) 2021-2023 Datalayer, Inc.\n *\n * MIT License\n */\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { PageConfig } from '@jupyterlab/coreutils';\nimport { BroadcastChannelWrapper, Contents, IContents, IBroadcastChannelWrapper, } from '../contents';\nimport { IKernels, Kernels, IKernelSpecs, KernelSpecs } from '../kernel';\nimport { ILicenses, Licenses } from '../licenses';\nimport { IServiceWorkerManager, ServiceWorkerManager, } from '../server';\nimport { ISessions, Sessions } from '../session';\nimport { ISettings, Settings } from '../settings';\nimport { ITranslation, Translation } from '../translation';\nimport { ILocalForage, ensureMemoryStorage } from '../localforage';\nimport localforage from 'localforage';\n/**\n * The localforage plugin\n */\nconst localforagePlugin = {\n    id: '@jupyterlite/server-extension:localforage',\n    autoStart: true,\n    provides: ILocalForage,\n    activate: (app) => {\n        return { localforage };\n    },\n};\n/**\n * The volatile localforage memory plugin\n */\nconst localforageMemoryPlugin = {\n    id: '@jupyterlite/server-extension:localforage-memory-storage',\n    autoStart: true,\n    requires: [ILocalForage],\n    activate: async (app, forage) => {\n        if (JSON.parse(PageConfig.getOption('enableMemoryStorage') || 'false')) {\n            console.warn('Memory storage fallback enabled: contents and settings may not be saved');\n            await ensureMemoryStorage(forage.localforage);\n        }\n    },\n};\n/**\n * A plugin providing the routes for the config section.\n * TODO: implement logic to persist the config sections?\n */\nconst configSectionRoutesPlugin = {\n    id: '@jupyterlite/server-extension:config-section-routes',\n    autoStart: true,\n    activate: (app) => {\n        const sections = {};\n        app.router.get('/api/config/(.*)', async (req, id) => {\n            const section = sections[id] ?? JSON.stringify({});\n            return new Response(section);\n        });\n        app.router.patch('/api/config/(.*)', async (req, id) => {\n            const payload = req.body;\n            sections[id] = payload;\n            return new Response(payload);\n        });\n    },\n};\n/**\n * The contents service plugin.\n */\nconst contentsPlugin = {\n    id: '@jupyterlite/server-extension:contents',\n    requires: [ILocalForage],\n    autoStart: true,\n    provides: IContents,\n    activate: (app, forage) => {\n        const storageName = PageConfig.getOption('contentsStorageName');\n        const storageDrivers = JSON.parse(PageConfig.getOption('contentsStorageDrivers') || 'null');\n        const { localforage } = forage;\n        const contents = new Contents({\n            storageName,\n            storageDrivers,\n            localforage,\n        });\n        app.started.then(() => contents.initialize().catch(console.warn));\n        return contents;\n    },\n};\n/**\n * A plugin providing the routes for the contents service.\n */\nconst contentsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:contents-routes',\n    autoStart: true,\n    requires: [IContents],\n    activate: (app, contents) => {\n        // GET /api/contents/{path}/checkpoints - Get a list of checkpoints for a file\n        app.router.get('/api/contents/(.+)/checkpoints', async (req, filename) => {\n            const res = await contents.listCheckpoints(filename);\n            return new Response(JSON.stringify(res));\n        });\n        // POST /api/contents/{path}/checkpoints/{checkpoint_id} - Restore a file to a particular checkpointed state\n        app.router.post('/api/contents/(.+)/checkpoints/(.*)', async (req, filename, checkpoint) => {\n            const res = await contents.restoreCheckpoint(filename, checkpoint);\n            return new Response(JSON.stringify(res), { status: 204 });\n        });\n        // POST /api/contents/{path}/checkpoints - Create a new checkpoint for a file\n        app.router.post('/api/contents/(.+)/checkpoints', async (req, filename) => {\n            const res = await contents.createCheckpoint(filename);\n            return new Response(JSON.stringify(res), { status: 201 });\n        });\n        // DELETE /api/contents/{path}/checkpoints/{checkpoint_id} - Delete a checkpoint\n        app.router.delete('/api/contents/(.+)/checkpoints/(.*)', async (req, filename, checkpoint) => {\n            const res = await contents.deleteCheckpoint(filename, checkpoint);\n            return new Response(JSON.stringify(res), { status: 204 });\n        });\n        // GET /api/contents/{path} - Get contents of file or directory\n        app.router.get('/api/contents(.*)', async (req, filename) => {\n            const options = {\n                content: req.query?.content === '1',\n            };\n            const nb = await contents.get(filename, options);\n            if (!nb) {\n                return new Response(null, { status: 404 });\n            }\n            return new Response(JSON.stringify(nb));\n        });\n        // POST /api/contents/{path} - Create a new file in the specified path\n        app.router.post('/api/contents(.*)', async (req, path) => {\n            const options = req.body;\n            const copyFrom = options?.copy_from;\n            let file;\n            if (copyFrom) {\n                file = await contents.copy(copyFrom, path);\n            }\n            else {\n                file = await contents.newUntitled(options);\n            }\n            if (!file) {\n                return new Response(null, { status: 400 });\n            }\n            return new Response(JSON.stringify(file), { status: 201 });\n        });\n        // PATCH /api/contents/{path} - Rename a file or directory without re-uploading content\n        app.router.patch('/api/contents(.*)', async (req, filename) => {\n            const newPath = req.body?.path ?? '';\n            filename = filename[0] === '/' ? filename.slice(1) : filename;\n            const nb = await contents.rename(filename, newPath);\n            return new Response(JSON.stringify(nb));\n        });\n        // PUT /api/contents/{path} - Save or upload a file\n        app.router.put('/api/contents/(.+)', async (req, filename) => {\n            const body = req.body;\n            const nb = await contents.save(filename, body);\n            return new Response(JSON.stringify(nb));\n        });\n        // DELETE /api/contents/{path} - Delete a file in the given path\n        app.router.delete('/api/contents/(.+)', async (req, filename) => {\n            await contents.delete(filename);\n            return new Response(null, { status: 204 });\n        });\n    },\n};\n/**\n * A plugin installing the service worker.\n */\nconst serviceWorkerPlugin = {\n    id: '@jupyterlite/server-extension:service-worker',\n    autoStart: true,\n    provides: IServiceWorkerManager,\n    activate: (app) => {\n        return new ServiceWorkerManager();\n    },\n};\n/**\n * A plugin for handling communication with the Emscpriten file system.\n */\nconst emscriptenFileSystemPlugin = {\n    id: '@jupyterlite/server-extension:emscripten-filesystem',\n    autoStart: true,\n    optional: [IServiceWorkerManager],\n    provides: IBroadcastChannelWrapper,\n    activate: (app, serviceWorkerRegistrationWrapper) => {\n        const { contents } = app.serviceManager;\n        const broadcaster = new BroadcastChannelWrapper({ contents });\n        const what = 'Kernel filesystem and JupyterLite contents';\n        function logStatus(msg, err) {\n            if (err) {\n                console.warn(err);\n            }\n            if (msg) {\n                console.warn(msg);\n            }\n            if (err || msg) {\n                console.warn(`${what} will NOT be synced`);\n            }\n            else {\n                // eslint-disable-next-line no-console\n                console.info(`${what} will be synced`);\n            }\n        }\n        if (!serviceWorkerRegistrationWrapper) {\n            logStatus('JupyterLite ServiceWorker not available');\n        }\n        else {\n            serviceWorkerRegistrationWrapper.ready\n                .then(() => {\n                broadcaster.enable();\n                logStatus();\n            })\n                .catch((err) => {\n                logStatus('JupyterLite ServiceWorker failed to become available', err);\n            });\n        }\n        return broadcaster;\n    },\n};\n/**\n * The kernels service plugin.\n */\nconst kernelsPlugin = {\n    id: '@jupyterlite/server-extension:kernels',\n    autoStart: true,\n    provides: IKernels,\n    requires: [IKernelSpecs],\n    activate: (app, kernelspecs) => {\n        return new Kernels({ kernelspecs });\n    },\n};\n/**\n * A plugin providing the routes for the kernels service\n */\nconst kernelsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:kernels-routes',\n    autoStart: true,\n    requires: [IKernels],\n    activate: (app, kernels) => {\n        // GET /api/kernels - List the running kernels\n        app.router.get('/api/kernels', async (req) => {\n            const res = await kernels.list();\n            return new Response(JSON.stringify(res));\n        });\n        // POST /api/kernels - Start a kernel\n        app.router.post('/api/kernels', async (req) => {\n            const name = req.body['name'] ?? 'python';\n            const res = await kernels.startNew({\n                id: '123',\n                name: name,\n                location: '/',\n            });\n            return new Response(JSON.stringify(res));\n        });\n        // POST /api/kernels/{kernel_id}/restart - Restart a kernel\n        app.router.post('/api/kernels/(.*)/restart', async (req, kernelId) => {\n            const res = await kernels.restart(kernelId);\n            return new Response(JSON.stringify(res));\n        });\n        // DELETE /api/kernels/{kernel_id} - Kill a kernel and delete the kernel id\n        app.router.delete('/api/kernels/(.*)', async (req, kernelId) => {\n            const res = await kernels.shutdown(kernelId);\n            return new Response(JSON.stringify(res), { status: 204 });\n        });\n    },\n};\n/**\n * The kernel spec service plugin.\n */\nconst kernelSpecPlugin = {\n    id: '@jupyterlite/server-extension:kernelspec',\n    autoStart: true,\n    provides: IKernelSpecs,\n    activate: (app) => {\n        return new KernelSpecs();\n    },\n};\n/**\n * A plugin providing the routes for the kernelspec service.\n */\nconst kernelSpecRoutesPlugin = {\n    id: '@jupyterlite/server-extension:kernelspec-routes',\n    autoStart: true,\n    requires: [IKernelSpecs],\n    activate: (app, kernelspecs) => {\n        app.router.get('/api/kernelspecs', async (req) => {\n            const { specs } = kernelspecs;\n            if (!specs) {\n                return new Response(null);\n            }\n            // follow the same format as in Jupyter Server\n            const allKernelSpecs = {};\n            const allSpecs = specs.kernelspecs;\n            Object.keys(allSpecs).forEach(name => {\n                const spec = allSpecs[name];\n                const { resources } = spec ?? {};\n                allKernelSpecs[name] = {\n                    name,\n                    spec,\n                    resources,\n                };\n            });\n            const res = {\n                default: specs.default,\n                kernelspecs: allKernelSpecs,\n            };\n            return new Response(JSON.stringify(res));\n        });\n    },\n};\n/**\n * The licenses service plugin\n */\nconst licensesPlugin = {\n    id: '@jupyterlite/server-extension:licenses',\n    autoStart: true,\n    provides: ILicenses,\n    activate: (app) => {\n        return new Licenses();\n    },\n};\n/**\n * A plugin providing the routes for the licenses service.\n */\nconst licensesRoutesPlugin = {\n    id: '@jupyterlite/server-extension:licenses-routes',\n    autoStart: true,\n    requires: [ILicenses],\n    activate(app, licenses) {\n        app.router.get('/api/licenses', async (req) => {\n            const res = await licenses.get();\n            return new Response(JSON.stringify(res));\n        });\n    },\n};\n/**\n * A plugin providing the routes for the lsp service.\n * TODO: provide the service in a separate plugin?\n */\nconst lspRoutesPlugin = {\n    id: '@jupyterlite/server-extension:lsp-routes',\n    autoStart: true,\n    activate: (app) => {\n        app.router.get('/lsp/status', async (req) => {\n            return new Response(JSON.stringify({ version: 2, sessions: {}, specs: {} }));\n        });\n    },\n};\n/**\n * A plugin providing the routes for the nbconvert service.\n * TODO: provide the service in a separate plugin?\n */\nconst nbconvertRoutesPlugin = {\n    id: '@jupyterlite/server-extension:nbconvert-routes',\n    autoStart: true,\n    activate: (app) => {\n        app.router.get('/api/nbconvert', async (req) => {\n            return new Response(JSON.stringify({}));\n        });\n    },\n};\n/**\n * The sessions service plugin.\n */\nconst sessionsPlugin = {\n    id: '@jupyterlite/server-extension:sessions',\n    autoStart: true,\n    provides: ISessions,\n    requires: [IKernels],\n    activate: (app, kernels) => {\n        return new Sessions({ kernels });\n    },\n};\n/**\n * A plugin providing the routes for the session service.\n */\nconst sessionsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:sessions-routes',\n    autoStart: true,\n    requires: [ISessions],\n    activate: (app, sessions) => {\n        // GET /api/sessions/{session} - Get session\n        app.router.get('/api/sessions/(.+)', async (req, id) => {\n            const session = await sessions.get(id);\n            return new Response(JSON.stringify(session), { status: 200 });\n        });\n        // GET /api/sessions - List available sessions\n        app.router.get('/api/sessions', async (req) => {\n            const list = await sessions.list();\n            return new Response(JSON.stringify(list), { status: 200 });\n        });\n        // PATCH /api/sessions/{session} - This can be used to rename a session\n        app.router.patch('/api/sessions(.*)', async (req, id) => {\n            const options = req.body;\n            const session = await sessions.patch(options);\n            return new Response(JSON.stringify(session), { status: 200 });\n        });\n        // DELETE /api/sessions/{session} - Delete a session\n        app.router.delete('/api/sessions/(.+)', async (req, id) => {\n            await sessions.shutdown(id);\n            return new Response(null, { status: 204 });\n        });\n        // POST /api/sessions - Create a new session or return an existing session if a session of the same name already exists\n        app.router.post('/api/sessions', async (req) => {\n            const options = req.body;\n            const session = await sessions.startNew(options);\n            return new Response(JSON.stringify(session), { status: 201 });\n        });\n    },\n};\n/**\n * The settings service plugin.\n */\nconst settingsPlugin = {\n    id: '@jupyterlite/server-extension:settings',\n    autoStart: true,\n    requires: [ILocalForage],\n    provides: ISettings,\n    activate: (app, forage) => {\n        const storageName = PageConfig.getOption('settingsStorageName');\n        const storageDrivers = JSON.parse(PageConfig.getOption('settingsStorageDrivers') || 'null');\n        const { localforage } = forage;\n        const settings = new Settings({ storageName, storageDrivers, localforage });\n        app.started.then(() => settings.initialize().catch(console.warn));\n        return settings;\n    },\n};\n/**\n * A plugin providing the routes for the settings service.\n */\nconst settingsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:settings-routes',\n    autoStart: true,\n    requires: [ISettings],\n    activate: (app, settings) => {\n        // TODO: improve the regex\n        // const pluginPattern = new RegExp(/(?:@([^/]+?)[/])?([^/]+?):(\\w+)/);\n        const pluginPattern = '/api/settings/((?:@([^/]+?)[/])?([^/]+?):([^:]+))$';\n        app.router.get(pluginPattern, async (req, pluginId) => {\n            const setting = await settings.get(pluginId);\n            return new Response(JSON.stringify(setting));\n        });\n        app.router.put(pluginPattern, async (req, pluginId) => {\n            const body = req.body;\n            const { raw } = body;\n            await settings.save(pluginId, raw);\n            return new Response(null, { status: 204 });\n        });\n        app.router.get('/api/settings', async (req) => {\n            const plugins = await settings.getAll();\n            return new Response(JSON.stringify(plugins));\n        });\n    },\n};\n/**\n * The translation service plugin.\n */\nconst translationPlugin = {\n    id: '@jupyterlite/server-extension:translation',\n    autoStart: true,\n    provides: ITranslation,\n    activate: (app) => {\n        const translation = new Translation();\n        app.router.get('/api/translations/?(.*)', async (req, locale) => {\n            if (locale === 'default') {\n                locale = 'en';\n            }\n            const data = await translation.get(locale || 'all');\n            return new Response(JSON.stringify(data));\n        });\n        return translation;\n    },\n};\n/**\n * A plugin providing the routes for the translation service.\n */\nconst translationRoutesPlugin = {\n    id: '@jupyterlite/server-extension:translation-routes',\n    autoStart: true,\n    requires: [ITranslation],\n    activate: (app, translation) => {\n        app.router.get('/api/translations/?(.*)', async (req, locale) => {\n            const data = await translation.get(locale || 'all');\n            return new Response(JSON.stringify(data));\n        });\n    },\n};\nconst plugins = [\n    configSectionRoutesPlugin,\n    contentsPlugin,\n    contentsRoutesPlugin,\n    emscriptenFileSystemPlugin,\n    kernelsPlugin,\n    kernelsRoutesPlugin,\n    kernelSpecPlugin,\n    kernelSpecRoutesPlugin,\n    licensesPlugin,\n    licensesRoutesPlugin,\n    localforageMemoryPlugin,\n    localforagePlugin,\n    lspRoutesPlugin,\n    nbconvertRoutesPlugin,\n    serviceWorkerPlugin,\n    sessionsPlugin,\n    sessionsRoutesPlugin,\n    settingsPlugin,\n    settingsRoutesPlugin,\n    translationPlugin,\n    translationRoutesPlugin,\n];\nexport default plugins;\n//# sourceMappingURL=index.js.map","/*\n * Copyright (c) 2021-2023 Datalayer, Inc.\n *\n * MIT License\n */\nimport memoryStorageDriver from 'localforage-memoryStorageDriver';\n/**\n * Ensure a localforage singleton has had the memory storage driver installed\n */\nexport async function ensureMemoryStorage(theLocalforage) {\n    return await theLocalforage.defineDriver(memoryStorageDriver);\n}\n//# sourceMappingURL=memory.js.map"],"names":["VERSION","PageConfig","getOption","ServiceWorkerManager","constructor","options","workerUrl","URLExt","join","fullWorkerUrl","URL","searchParams","set","this","initialize","href","catch","console","warn","registrationChanged","_registrationChanged","enabled","_registration","ready","_ready","promise","unregisterOldServiceWorkers","async","scriptURL","versionKey","installedVersion","localStorage","getItem","info","registrations","navigator","serviceWorker","getRegistrations","Promise","all","map","registration","unregister","setItem","controller","getRegistration","register","err","_setRegistration","resolve","setTimeout","_pingServiceWorker","reject","response","fetch","text","emit","Signal","PromiseDelegate","DEFAULT_STORAGE_NAME","encoder","TextEncoder","decoder","TextDecoder","Contents","_localforage","localforage","_storageName","storageName","_storageDrivers","storageDrivers","initStorage","_storage","createDefaultStorage","_counters","createDefaultCounters","_checkpoints","createDefaultCheckpoints","storage","then","counters","checkpoints","defaultStorageOptions","driver","length","version","name","createInstance","description","storeName","newUntitled","path","type","created","Date","toISOString","dirname","PathExt","basename","extname","item","get","file","_incrementCounter","last_modified","format","mimetype","content","size","writable","counter","MIME","JSON","Private","EMPTY_NB","encode","stringify","ext","FILE","getType","OCTET_STREAM","hasFormat","indexOf","key","copy","toDir","removeSlash","base","replace","toPath","Error","decodeURIComponent","_getFolder","serverItem","_getServerContents","model","contentMap","Map","iterate","serverContents","Array","from","_getServerDirectory","values","has","rename","oldLocalPath","newLocalPath","modified","newFile","removeItem","child","save","chunk","appendChunk","originalContent","lastChunk","contentBinaryString","_handleUploadChunk","parse","decode","_binaryStringToBytes","btoa","slashed","toDelete","keys","filter","startsWith","forgetPath","createCheckpoint","copies","Boolean","push","splice","id","listCheckpoints","normalizeCheckpoint","toString","restoreCheckpoint","checkpointID","parseInt","deleteCheckpoint","newContent","newContentBinaryString","atob","binaryString","bytes","Uint8Array","i","charCodeAt","includes","PLAIN_TEXT","fileUrl","getBaseUrl","ok","headers","match","contentText","contentBuffer","arrayBuffer","contentBytes","reduce","reduceBytesToString","data","byte","String","fromCharCode","_serverContents","apiURL","json","metadata","orig_nbformat","nbformat_minor","nbformat","cells","BroadcastChannelWrapper","isDisposed","_contents","contents","_driveContentsProcessor","DriveContentsProcessor","contentsManager","_enabled","enable","_channel","BroadcastChannel","DRIVE_API_PATH","addEventListener","_onMessage","disable","removeEventListener","dispose","event","request","receiver","processDriveRequest","postMessage","E_CANCELED","__awaiter$2","thisArg","_arguments","P","generator","fulfilled","value","step","next","e","rejected","result","done","apply","Semaphore","_maxConcurrency","_cancelError","_queue","_waiters","_value","acquire","locked","isLocked","ticketPromise","_dispatch","runExclusive","callback","release","waitForUnlock","_currentReleaser","releaser","cancel","forEach","ticket","nextTicket","shift","released","_resolveWaiters","waiter","__awaiter$1","Mutex","cancelError","_semaphore","KERNEL_WEBSOCKET_PROTOCOL","supportedKernelWebSocketProtocols","v1KernelWebsocketJupyterOrg","Kernels","kernelspecs","_kernelspecs","_kernels","changed","connect","_","args","_changed","startNew","location","factory","factories","error","mutex","hook","kernelId","clientId","socket","kernel","_clients","_kernelClients","add","on","message","msg","ArrayBuffer","buffer","deserialize","encodedData","header","msg_type","handleMessage","processMsg","removeClient","delete","disposed","onclose","UUID","uuid4","kernelUrl","WS_BASE_URL","KernelAPI","KERNEL_SERVICE_URL","encodeURIComponent","runningKernel","sendMessage","session","serialize","channel","clients","send","Set","wsServer","WebSocketServer","mock","selectProtocol","url","readyState","WebSocket","CLOSED","close","restart","list","shutdown","ObservableMap","KernelSpecs","specs","_specs","default","defaultKernelName","Object","fromEntries","sort","FALLBACK_KERNEL","_factories","spec","create","ILocalForage","Token","getSerializerPromise","localForageInstance","getSerializer","executeCallback","storageRepository","memoryStorageDriver","_driver","_initStorage","dbInfo","database","table","db","_dbInfo","serializer","iterator","self","iterationNumber","hasOwnProperty","originalValue","clear","n","index","ISessions","Sessions","kernels","oldValue","_sessions","find","s","_pendingRestarts","newValue","patch","findIndex","patched","newKernel","_handleKernelShutdown","sessionId","running","kernelName","nameOrPath","driveName","split","ArrayExt","removeFirstOf","THIRD_PARTY_LICENSES","ILicenses","EMPTY_BUNDLE","freeze","packages","Licenses","bundles","_getFederated","appName","_getAppLicenses","appLicensesUrl","labExtensionsUrl","bundle","federated","promises","_getOneFederated","Settings","defaultSettingsStorage","pluginId","getAll","settings","setting","allCore","_getAll","allFederated","concat","plugin","raw","override","json5.parse","settingsUrl","_overrides","schema","properties","prop","propDefault","entries","ISettings","Translation","locale","_prevLocale","prev","displayName","nativeName","en","ITranslation","exports","t","r","o","u","a","require","f","code","l","call","_dereq_","module","global","scheduleDrain","draining","Mutation","MutationObserver","WebKitMutationObserver","called","observer","nextTick","element","document","createTextNode","observe","characterData","setImmediate","MessageChannel","createElement","scriptEl","onreadystatechange","parentNode","removeChild","documentElement","appendChild","port1","onmessage","port2","queue","oldQueue","len","immediate","task","globalThis","window","INTERNAL","handlers","REJECTED","FULFILLED","PENDING","resolver","TypeError","state","outcome","safelyResolveThenable","QueueItem","onFulfilled","onRejected","callFulfilled","otherCallFulfilled","callRejected","otherCallRejected","unwrap","func","returnValue","getThen","obj","arguments","thenable","onError","onSuccess","tryToUnwrap","tryCatch","status","out","reason","iterable","prototype","resolved","allResolver","resolveFromAll","outValue","race","_typeof","Symbol","_classCallCheck","instance","Constructor","getIDB","indexedDB","webkitIndexedDB","mozIndexedDB","OIndexedDB","msIndexedDB","idb","isIndexedDBValid","open","isSafari","openDatabase","test","userAgent","platform","hasFetch","IDBKeyRange","createBlob","parts","Blob","builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","append","getBlob","Promise$1","executeTwoCallbacks","errorCallback","normalizeKey","getCallback","DETECT_BLOB_SUPPORT_STORE","supportsBlobs","dbContexts","READ_ONLY","READ_WRITE","_binStringToArrayBuffer","bin","buf","arr","_checkBlobSupportWithoutCaching","txn","transaction","blob","objectStore","put","onabort","preventDefault","stopPropagation","oncomplete","matchedChrome","matchedEdge","_checkBlobSupport","_deferReadiness","dbContext","deferredOperation","deferredOperations","dbReady","_advanceReadiness","pop","_rejectReadiness","_getConnection","upgradeNeeded","createDbContext","dbArgs","openreq","onupgradeneeded","createObjectStore","oldVersion","ex","newVersion","onerror","onsuccess","onversionchange","target","_getOriginalConnection","_getUpgradedConnection","_isUpgradeNeeded","defaultVersion","isNewStore","objectStoreNames","contains","isDowngrade","isUpgrade","incVersion","_encodeBlob","reader","FileReader","onloadend","base64","__local_forage_encoded_blob","readAsBinaryString","_decodeBlob","encodedBlob","_isEncodedBlob","_fullyReady","_initReady","_tryReconnect","forages","forage","createTransaction","mode","retries","tx","initPromises","ignoreErrors","j","slice","_defaultConfig","k","req","openCursor","cursor","blobSupport","store","count","advanced","openKeyCursor","advance","dropInstance","currentConfig","config","dbPromise","deleteObjectStore","_forage2","deleteDatabase","onblocked","asyncStorage","_support","isWebSQLValid","BASE_CHARS","BLOB_TYPE_PREFIX","BLOB_TYPE_PREFIX_REGEX","SERIALIZED_MARKER","SERIALIZED_MARKER_LENGTH","TYPE_ARRAYBUFFER","TYPE_BLOB","TYPE_INT8ARRAY","TYPE_UINT8ARRAY","TYPE_UINT8CLAMPEDARRAY","TYPE_INT16ARRAY","TYPE_INT32ARRAY","TYPE_UINT16ARRAY","TYPE_UINT32ARRAY","TYPE_FLOAT32ARRAY","TYPE_FLOAT64ARRAY","TYPE_SERIALIZED_MARKER_LENGTH","toString$1","stringToBuffer","serializedString","encoded1","encoded2","encoded3","encoded4","bufferLength","p","bufferToString","base64String","substring","valueType","marker","fileReader","onload","str","readAsArrayBuffer","blobType","matcher","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","localforageSerializer","createDbTable","executeSql","_initStorage$1","dbInfoPromise","tryExecuteSql","sqlStatement","SYNTAX_ERR","results","rows","getItem$1","iterate$1","_setItem","retriesLeft","sqlError","QUOTA_ERR","setItem$1","removeItem$1","clear$1","length$1","c","key$1","keys$1","getAllStoreNames","storeNames","dropInstance$1","operationInfo","dropTable","operations","webSQLStorage","isLocalStorageValid","_getKeyPrefix","defaultConfig","keyPrefix","checkIfLocalStorageThrows","localStorageTestKey","_isLocalStorageUsable","_initStorage$2","clear$2","getItem$2","iterate$2","keyPrefixLength","key$2","keys$2","itemKey","length$2","removeItem$2","setItem$2","dropInstance$2","localStorageWrapper","sameValue","x","y","isNaN","array","searchElement","isArray","arg","DefinedDrivers","DriverSupport","DefaultDrivers","INDEXEDDB","WEBSQL","LOCALSTORAGE","DefaultDriverOrder","OptionalDriverMethods","LibraryMethods","DefaultConfig","callWhenReady","libraryMethod","_args","extend","_key","LocalForage","driverTypeKey","driverName","defineDriver","_config","_driverSet","_initDriver","_wrapLibraryMethodsWithReady","setDriver","driverObject","complianceError","driverMethods","driverMethodName","configureMissingMethods","methodNotImplementedFactory","methodName","_i","_len","optionalDriverMethod","setDriverSupport","support","getDriver","getDriverPromise","serializerPromise","drivers","supportedDrivers","_getSupportedDrivers","setDriverToConfig","extendSelfWithDriver","_extend","initDriver","currentDriverIndex","driverPromiseLoop","oldDriverSetDone","supports","libraryMethodsAndProperties","localforage_js","localforagePlugin","autoStart","provides","activate","app","localforageMemoryPlugin","requires","theLocalforage","ensureMemoryStorage","serviceWorkerPlugin","IServiceWorkerManager","plugins","sections","router","section","Response","payload","body","IContents","started","filename","res","post","checkpoint","query","nb","copyFrom","copy_from","newPath","optional","IBroadcastChannelWrapper","serviceWorkerRegistrationWrapper","serviceManager","broadcaster","what","logStatus","IKernels","IKernelSpecs","allKernelSpecs","allSpecs","resources","licenses","sessions","pluginPattern","translation"],"mappings":"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","x_google_ignoreList":[3,7,16]}