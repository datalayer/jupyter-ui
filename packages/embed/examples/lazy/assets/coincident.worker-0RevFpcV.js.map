{"version":3,"file":"coincident.worker-0RevFpcV.js","sources":["../../../node_modules/proxy-target/esm/types.js","../../../node_modules/coincident/esm/channel.js","../../../node_modules/proxy-target/esm/traps.js","../../../node_modules/coincident/esm/bridge.js","../../../node_modules/coincident/esm/index.js","../../react/lib/jupyter/lite/contents/emscripten.js","../../react/lib/jupyter/lite/contents/drivefs.js","../../react/lib/jupyter/lite/pyodide-kernel/worker.js","../../react/lib/jupyter/lite/pyodide-kernel/coincident.worker.js"],"sourcesContent":["export const ARRAY     = 'array';\nexport const BIGINT    = 'bigint';\nexport const BOOLEAN   = 'boolean';\nexport const FUNCTION  = 'function';\nexport const NULL      = 'null';\nexport const NUMBER    = 'number';\nexport const OBJECT    = 'object';\nexport const STRING    = 'string';\nexport const SYMBOL    = 'symbol';\nexport const UNDEFINED = 'undefined';\n","// âš ï¸ AUTOMATICALLY GENERATED - DO NOT CHANGE\nexport const CHANNEL = '64e10b34-2bf7-4616-9668-f99de5aa046e';\n\nexport const MAIN = 'M' + CHANNEL;\nexport const THREAD = 'T' + CHANNEL;\n","export const APPLY                        = 'apply';\nexport const CONSTRUCT                    = 'construct';\nexport const DEFINE_PROPERTY              = 'defineProperty';\nexport const DELETE_PROPERTY              = 'deleteProperty';\nexport const GET                          = 'get';\nexport const GET_OWN_PROPERTY_DESCRIPTOR  = 'getOwnPropertyDescriptor';\nexport const GET_PROTOTYPE_OF             = 'getPrototypeOf';\nexport const HAS                          = 'has';\nexport const IS_EXTENSIBLE                = 'isExtensible';\nexport const OWN_KEYS                     = 'ownKeys';\nexport const PREVENT_EXTENSION            = 'preventExtensions';\nexport const SET                          = 'set';\nexport const SET_PROTOTYPE_OF             = 'setPrototypeOf';\n","// The goal of this file is to normalize SAB\n// at least in main -> worker() use cases.\n// This still cannot possibly solve the sync\n// worker -> main() use case if SharedArrayBuffer\n// is not available or usable.\n\nimport {CHANNEL} from './channel.js';\n\nconst {isArray} = Array;\n\nlet {SharedArrayBuffer, window} = globalThis;\nlet {notify, wait, waitAsync} = Atomics;\nlet postPatched = null;\n\n// This is needed for some version of Firefox\nif (!waitAsync) {\n  waitAsync = buffer => ({\n    value: new Promise(onmessage => {\n      // encodeURIComponent('onmessage=({data:b})=>(Atomics.wait(b,0),postMessage(0))')\n      let w = new Worker('data:application/javascript,onmessage%3D(%7Bdata%3Ab%7D)%3D%3E(Atomics.wait(b%2C0)%2CpostMessage(0))');\n      w.onmessage = onmessage;\n      w.postMessage(buffer);\n    })\n  });\n}\n\n// Monkey-patch SharedArrayBuffer if needed\ntry {\n  new SharedArrayBuffer(4);\n}\ncatch (_) {\n  SharedArrayBuffer = ArrayBuffer;\n\n  const ids = new WeakMap;\n  // patch only main -> worker():async use case\n  if (window) {\n    const resolvers = new Map;\n    const {prototype: {postMessage}} = Worker;\n\n    const listener = event => {\n      const details = event.data?.[CHANNEL];\n      if (!isArray(details)) {\n        event.stopImmediatePropagation();\n        const { id, sb } = details;\n        resolvers.get(id)(sb);\n      }\n    };\n\n    postPatched = function (data, ...rest) {\n      const details = data?.[CHANNEL];\n      if (isArray(details)) {\n        const [id, sb] = details;\n        ids.set(sb, id);\n        this.addEventListener('message', listener);\n      }\n      return postMessage.call(this, data, ...rest);\n    };\n\n    waitAsync = sb => ({\n      value: new Promise(resolve => {\n        resolvers.set(ids.get(sb), resolve);\n      }).then(buff => {\n        resolvers.delete(ids.get(sb));\n        ids.delete(sb);\n        for (let i = 0; i < buff.length; i++) sb[i] = buff[i];\n        return 'ok';\n      })\n    });\n  }\n  else {\n    const as = (id, sb) => ({[CHANNEL]: { id, sb }});\n\n    notify = sb => {\n      postMessage(as(ids.get(sb), sb));\n    };\n\n    addEventListener('message', event => {\n      const details = event.data?.[CHANNEL];\n      if (isArray(details)) {\n        const [id, sb] = details;\n        ids.set(sb, id);\n      }\n    });\n  }\n}\n\nexport {SharedArrayBuffer, isArray, notify, postPatched, wait, waitAsync};\n","/*! (c) Andrea Giammarchi - ISC */\n\nimport {FUNCTION} from 'proxy-target/types';\n\nimport {CHANNEL} from './channel.js';\nimport {GET, HAS, SET} from './shared/traps.js';\n\nimport {SharedArrayBuffer, isArray, notify, postPatched, wait, waitAsync} from './bridge.js';\n\n// just minifier friendly for Blob Workers' cases\nconst {Int32Array, Map, Uint16Array} = globalThis;\n\n// common constants / utilities for repeated operations\nconst {BYTES_PER_ELEMENT: I32_BYTES} = Int32Array;\nconst {BYTES_PER_ELEMENT: UI16_BYTES} = Uint16Array;\n\nconst waitInterrupt = (sb, delay, handler) => {\n  while (wait(sb, 0, 0, delay) === 'timed-out')\n    handler();\n};\n\n// retain buffers to transfer\nconst buffers = new WeakSet;\n\n// retain either main threads or workers global context\nconst context = new WeakMap;\n\nconst syncResult = {value: {then: fn => fn()}};\n\n// used to generate a unique `id` per each worker `postMessage` \"transaction\"\nlet uid = 0;\n\n/**\n * @typedef {Object} Interrupt used to sanity-check interrupts while waiting synchronously.\n * @prop {function} [handler] a callback invoked every `delay` milliseconds.\n * @prop {number} [delay=42] define `handler` invokes in terms of milliseconds.\n */\n\n/**\n * Create once a `Proxy` able to orchestrate synchronous `postMessage` out of the box.\n * @param {globalThis | Worker} self the context in which code should run\n * @param {{parse: (serialized: string) => any, stringify: (serializable: any) => string, transform?: (value:any) => any, interrupt?: () => void | Interrupt}} [JSON] an optional `JSON` like interface to `parse` or `stringify` content with extra `transform` ability.\n * @returns {ProxyHandler<globalThis> | ProxyHandler<Worker>}\n */\nconst coincident = (self, {parse = JSON.parse, stringify = JSON.stringify, transform, interrupt} = JSON) => {\n  // create a Proxy once for the given context (globalThis or Worker instance)\n  if (!context.has(self)) {\n    // ensure no SAB gets a chance to pass through this call\n    const sendMessage = postPatched || self.postMessage;\n    // ensure the CHANNEL and data are posted correctly\n    const post = (transfer, ...args) => sendMessage.call(self, {[CHANNEL]: args}, {transfer});\n\n    const handler = typeof interrupt === FUNCTION ? interrupt : interrupt?.handler;\n    const delay = interrupt?.delay || 42;\n    const decoder = new TextDecoder('utf-16');\n\n    // automatically uses sync wait (worker -> main)\n    // or fallback to async wait (main -> worker)\n    const waitFor = (isAsync, sb) => isAsync ?\n      waitAsync(sb, 0) :\n      ((handler ? waitInterrupt(sb, delay, handler) : wait(sb, 0)), syncResult);\n\n    // prevent Harakiri https://github.com/WebReflection/coincident/issues/18\n    let seppuku = false;\n\n    context.set(self, new Proxy(new Map, {\n      // there is very little point in checking prop in proxy for this very specific case\n      // and I don't want to orchestrate a whole roundtrip neither, as stuff would fail\n      // regardless if from Worker we access non existent Main callback, and vice-versa.\n      // This is here mostly to guarantee that if such check is performed, at least the\n      // get trap goes through and then it's up to developers guarantee they are accessing\n      // stuff that actually exists elsewhere.\n      [HAS]: (_, action) => typeof action === 'string' && !action.startsWith('_'),\n\n      // worker related: get any utility that should be available on the main thread\n      [GET]: (_, action) => action === 'then' ? null : ((...args) => {\n        // transaction id\n        const id = uid++;\n\n        // first contact: just ask for how big the buffer should be\n        // the value would be stored at index [1] while [0] is just control\n        let sb = new Int32Array(new SharedArrayBuffer(I32_BYTES * 2));\n\n        // if a transfer list has been passed, drop it from args\n        let transfer = [];\n        if (buffers.has(args.at(-1) || transfer))\n          buffers.delete(transfer = args.pop());\n\n        // ask for invoke with arguments and wait for it\n        post(transfer, id, sb, action, transform ? args.map(transform) : args);\n\n        // helps deciding how to wait for results\n        const isAsync = self !== globalThis;\n\n        // warn users about possible deadlock still allowing them\n        // to explicitly `proxy.invoke().then(...)` without blocking\n        let deadlock = 0;\n        if (seppuku && isAsync)\n          deadlock = setTimeout(console.warn, 1000, `ðŸ’€ðŸ”’ - Possible deadlock if proxy.${action}(...args) is awaited`);\n\n        return waitFor(isAsync, sb).value.then(() => {\n          clearTimeout(deadlock);\n\n          // commit transaction using the returned / needed buffer length\n          const length = sb[1];\n\n          // filter undefined results\n          if (!length) return;\n\n          // calculate the needed ui16 bytes length to store the result string\n          const bytes = UI16_BYTES * length;\n\n          // round up to the next amount of bytes divided by 4 to allow i32 operations\n          sb = new Int32Array(new SharedArrayBuffer(bytes + (bytes % I32_BYTES)));\n\n          // ask for results and wait for it\n          post([], id, sb);\n          return waitFor(isAsync, sb).value.then(() => parse(\n            decoder.decode(new Uint16Array(sb.buffer).slice(0, length)))\n          );\n        });\n      }),\n\n      // main thread related: react to any utility a worker is asking for\n      [SET](actions, action, callback) {\n        const type = typeof callback;\n        if (type !== FUNCTION)\n          throw new Error(`Unable to assign ${action} as ${type}`);\n        // lazy event listener and logic handling, triggered once by setters actions\n        if (!actions.size) {\n          // maps results by `id` as they are asked for\n          const results = new Map;\n          // add the event listener once (first defined setter, all others work the same)\n          self.addEventListener('message', async (event) => {\n            // grub the very same library CHANNEL; ignore otherwise\n            const details = event.data?.[CHANNEL];\n            if (isArray(details)) {\n              // if early enough, avoid leaking data to other listeners\n              event.stopImmediatePropagation();\n              const [id, sb, ...rest] = details;\n              let error;\n              // action available: it must be defined/known on the main thread\n              if (rest.length) {\n                const [action, args] = rest;\n                if (actions.has(action)) {\n                  seppuku = true;\n                  try {\n                    // await for result either sync or async and serialize it\n                    const result = await actions.get(action)(...args);\n                    if (result !== void 0) {\n                      const serialized = stringify(transform ? transform(result) : result);\n                      // store the result for \"the very next\" event listener call\n                      results.set(id, serialized);\n                      // communicate the required SharedArrayBuffer length out of the\n                      // resulting serialized string\n                      sb[1] = serialized.length;\n                    }\n                  }\n                  catch (_) {\n                    error = _;\n                  }\n                  finally {\n                    seppuku = false;\n                  }\n                }\n                // unknown action should be notified as missing on the main thread\n                else {\n                  error = new Error(`Unsupported action: ${action}`);\n                }\n                // unlock the wait lock later on\n                sb[0] = 1;\n              }\n              // no action means: get results out of the well known `id`\n              // wait lock automatically unlocked here as no `0` value would\n              // possibly ever land at index `0`\n              else {\n                const result = results.get(id);\n                results.delete(id);\n                // populate the SharedArrayBuffer with utf-16 chars code\n                for (let ui16a = new Uint16Array(sb.buffer), i = 0; i < result.length; i++)\n                  ui16a[i] = result.charCodeAt(i);\n              }\n              // release te worker waiting either the length or the result\n              notify(sb, 0);\n              if (error) throw error;\n            }\n          });\n        }\n        // store this action callback allowing the setter in the process\n        return !!actions.set(action, callback);\n      }\n    }));\n  }\n  return context.get(self);\n};\n\ncoincident.transfer = (...args) => (buffers.add(args), args);\n\nexport default coincident;\n","/*\n * Copyright (c) 2021-2023 Datalayer, Inc.\n *\n * MIT License\n */\n/// <reference types=\"emscripten\" />\nexport const DIR_MODE = 16895; // 040777\nexport const FILE_MODE = 33206; // 100666\nexport const SEEK_CUR = 1;\nexport const SEEK_END = 2;\nexport function instanceOfStream(nodeOrStream) {\n    return 'node' in nodeOrStream;\n}\n//# sourceMappingURL=emscripten.js.map","/*\n * Copyright (c) 2021-2023 Datalayer, Inc.\n *\n * MIT License\n */\nimport { DIR_MODE, SEEK_CUR, SEEK_END, instanceOfStream, } from './emscripten';\nexport const DRIVE_SEPARATOR = ':';\nexport const DRIVE_API_PATH = '/api/drive.v1';\nexport const BLOCK_SIZE = 4096;\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder('utf-8');\n// Mapping flag -> do we need to overwrite the file upon closing it\nconst flagNeedsWrite = {\n    0 /*O_RDONLY*/: false,\n    1 /*O_WRONLY*/: true,\n    2 /*O_RDWR*/: true,\n    64 /*O_CREAT*/: true,\n    65 /*O_WRONLY|O_CREAT*/: true,\n    66 /*O_RDWR|O_CREAT*/: true,\n    129 /*O_WRONLY|O_EXCL*/: true,\n    193 /*O_WRONLY|O_CREAT|O_EXCL*/: true,\n    514 /*O_RDWR|O_TRUNC*/: true,\n    577 /*O_WRONLY|O_CREAT|O_TRUNC*/: true,\n    578 /*O_CREAT|O_RDWR|O_TRUNC*/: true,\n    705 /*O_WRONLY|O_CREAT|O_EXCL|O_TRUNC*/: true,\n    706 /*O_RDWR|O_CREAT|O_EXCL|O_TRUNC*/: true,\n    1024 /*O_APPEND*/: true,\n    1025 /*O_WRONLY|O_APPEND*/: true,\n    1026 /*O_RDWR|O_APPEND*/: true,\n    1089 /*O_WRONLY|O_CREAT|O_APPEND*/: true,\n    1090 /*O_RDWR|O_CREAT|O_APPEND*/: true,\n    1153 /*O_WRONLY|O_EXCL|O_APPEND*/: true,\n    1154 /*O_RDWR|O_EXCL|O_APPEND*/: true,\n    1217 /*O_WRONLY|O_CREAT|O_EXCL|O_APPEND*/: true,\n    1218 /*O_RDWR|O_CREAT|O_EXCL|O_APPEND*/: true,\n    4096 /*O_RDONLY|O_DSYNC*/: true,\n    4098 /*O_RDWR|O_DSYNC*/: true,\n};\nexport class DriveFSEmscriptenStreamOps {\n    fs;\n    constructor(fs) {\n        this.fs = fs;\n    }\n    open(stream) {\n        const path = this.fs.realPath(stream.node);\n        if (this.fs.FS.isFile(stream.node.mode)) {\n            stream.file = this.fs.API.get(path);\n        }\n    }\n    close(stream) {\n        if (!this.fs.FS.isFile(stream.node.mode) || !stream.file) {\n            return;\n        }\n        const path = this.fs.realPath(stream.node);\n        const flags = stream.flags;\n        let parsedFlags = typeof flags === 'string' ? parseInt(flags, 10) : flags;\n        parsedFlags &= 0x1fff;\n        let needsWrite = true;\n        if (parsedFlags in flagNeedsWrite) {\n            needsWrite = flagNeedsWrite[parsedFlags];\n        }\n        if (needsWrite) {\n            this.fs.API.put(path, stream.file);\n        }\n        stream.file = undefined;\n    }\n    read(stream, buffer, offset, length, position) {\n        if (length <= 0 ||\n            stream.file === undefined ||\n            position >= (stream.file.data.length || 0)) {\n            return 0;\n        }\n        const size = Math.min(stream.file.data.length - position, length);\n        buffer.set(stream.file.data.subarray(position, position + size), offset);\n        return size;\n    }\n    write(stream, buffer, offset, length, position) {\n        if (length <= 0 || stream.file === undefined) {\n            return 0;\n        }\n        stream.node.timestamp = Date.now();\n        if (position + length > (stream.file?.data.length || 0)) {\n            const oldData = stream.file.data ? stream.file.data : new Uint8Array();\n            stream.file.data = new Uint8Array(position + length);\n            stream.file.data.set(oldData);\n        }\n        stream.file.data.set(buffer.subarray(offset, offset + length), position);\n        return length;\n    }\n    llseek(stream, offset, whence) {\n        let position = offset;\n        if (whence === SEEK_CUR) {\n            position += stream.position;\n        }\n        else if (whence === SEEK_END) {\n            if (this.fs.FS.isFile(stream.node.mode)) {\n                if (stream.file !== undefined) {\n                    position += stream.file.data.length;\n                }\n                else {\n                    throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES.EPERM);\n                }\n            }\n        }\n        if (position < 0) {\n            throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES.EINVAL);\n        }\n        return position;\n    }\n}\nexport class DriveFSEmscriptenNodeOps {\n    fs;\n    constructor(fs) {\n        this.fs = fs;\n    }\n    node(nodeOrStream) {\n        if (instanceOfStream(nodeOrStream)) {\n            return nodeOrStream.node;\n        }\n        return nodeOrStream;\n    }\n    getattr(value) {\n        const node = this.node(value);\n        return {\n            ...this.fs.API.getattr(this.fs.realPath(node)),\n            mode: node.mode,\n            ino: node.id,\n        };\n    }\n    setattr(value, attr) {\n        const node = this.node(value);\n        for (const [key, value] of Object.entries(attr)) {\n            switch (key) {\n                case 'mode':\n                    node.mode = value;\n                    break;\n                case 'timestamp':\n                    node.timestamp = value;\n                    break;\n                case 'size': {\n                    const size = value;\n                    const path = this.fs.realPath(node);\n                    if (this.fs.FS.isFile(node.mode) && size >= 0) {\n                        const file = this.fs.API.get(path);\n                        const oldData = file.data ? file.data : new Uint8Array();\n                        if (size !== oldData.length) {\n                            if (size < oldData.length) {\n                                file.data = file.data.slice(0, size);\n                            }\n                            else {\n                                file.data = new Uint8Array(size);\n                                file.data.set(oldData);\n                            }\n                            this.fs.API.put(path, file);\n                        }\n                    }\n                    else {\n                        console.warn('setattr size of', size, 'on', node, 'not yet implemented');\n                    }\n                    break;\n                }\n                default:\n                    console.warn('setattr', key, 'of', value, 'on', node, 'not yet implemented');\n                    break;\n            }\n        }\n    }\n    lookup(parent, name) {\n        const node = this.node(parent);\n        const path = this.fs.PATH.join2(this.fs.realPath(node), name);\n        const result = this.fs.API.lookup(path);\n        if (!result.ok) {\n            throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['ENOENT']);\n        }\n        return this.fs.createNode(node, name, result.mode, 0);\n    }\n    mknod(parent, name, mode, dev) {\n        const node = this.node(parent);\n        const path = this.fs.PATH.join2(this.fs.realPath(node), name);\n        this.fs.API.mknod(path, mode);\n        return this.fs.createNode(node, name, mode, dev);\n    }\n    rename(value, newDir, newName) {\n        const oldNode = this.node(value);\n        const newDirNode = this.node(newDir);\n        this.fs.API.rename(oldNode.parent\n            ? this.fs.PATH.join2(this.fs.realPath(oldNode.parent), oldNode.name)\n            : oldNode.name, this.fs.PATH.join2(this.fs.realPath(newDirNode), newName));\n        // Updating the in-memory node\n        oldNode.name = newName;\n        oldNode.parent = newDirNode;\n    }\n    unlink(parent, name) {\n        this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(this.node(parent)), name));\n    }\n    rmdir(parent, name) {\n        this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(this.node(parent)), name));\n    }\n    readdir(value) {\n        return this.fs.API.readdir(this.fs.realPath(this.node(value)));\n    }\n    symlink(parent, newName, oldPath) {\n        throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n    }\n    readlink(node) {\n        throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n    }\n}\n/**\n * ContentsAPI base class\n */\nexport class ContentsAPI {\n    constructor(driveName, mountpoint, FS, ERRNO_CODES) {\n        this._driveName = driveName;\n        this._mountpoint = mountpoint;\n        this.FS = FS;\n        this.ERRNO_CODES = ERRNO_CODES;\n    }\n    lookup(path) {\n        return this.request({ method: 'lookup', path: this.normalizePath(path) });\n    }\n    getmode(path) {\n        return this.request({ method: 'getmode', path: this.normalizePath(path) });\n    }\n    mknod(path, mode) {\n        return this.request({\n            method: 'mknod',\n            path: this.normalizePath(path),\n            data: { mode },\n        });\n    }\n    rename(oldPath, newPath) {\n        return this.request({\n            method: 'rename',\n            path: this.normalizePath(oldPath),\n            data: { newPath: this.normalizePath(newPath) },\n        });\n    }\n    readdir(path) {\n        const dirlist = this.request({\n            method: 'readdir',\n            path: this.normalizePath(path),\n        });\n        dirlist.push('.');\n        dirlist.push('..');\n        return dirlist;\n    }\n    rmdir(path) {\n        return this.request({ method: 'rmdir', path: this.normalizePath(path) });\n    }\n    get(path) {\n        const response = this.request({\n            method: 'get',\n            path: this.normalizePath(path),\n        });\n        if (!response) {\n            throw new this.FS.ErrnoError(this.ERRNO_CODES['ENOENT']);\n        }\n        const serializedContent = response.content;\n        const format = response.format;\n        switch (format) {\n            case 'json':\n            case 'text':\n                return {\n                    data: encoder.encode(serializedContent),\n                    format,\n                };\n            case 'base64': {\n                const binString = atob(serializedContent);\n                const len = binString.length;\n                const data = new Uint8Array(len);\n                for (let i = 0; i < len; i++) {\n                    data[i] = binString.charCodeAt(i);\n                }\n                return {\n                    data,\n                    format,\n                };\n            }\n            default:\n                throw new this.FS.ErrnoError(this.ERRNO_CODES['ENOENT']);\n        }\n    }\n    put(path, value) {\n        switch (value.format) {\n            case 'json':\n            case 'text':\n                return this.request({\n                    method: 'put',\n                    path: this.normalizePath(path),\n                    data: {\n                        format: value.format,\n                        data: decoder.decode(value.data),\n                    },\n                });\n            case 'base64': {\n                let binary = '';\n                for (let i = 0; i < value.data.byteLength; i++) {\n                    binary += String.fromCharCode(value.data[i]);\n                }\n                return this.request({\n                    method: 'put',\n                    path: this.normalizePath(path),\n                    data: {\n                        format: value.format,\n                        data: btoa(binary),\n                    },\n                });\n            }\n        }\n    }\n    getattr(path) {\n        const stats = this.request({\n            method: 'getattr',\n            path: this.normalizePath(path),\n        });\n        // Turn datetimes into proper objects\n        if (stats.atime) {\n            stats.atime = new Date(stats.atime);\n        }\n        if (stats.mtime) {\n            stats.mtime = new Date(stats.mtime);\n        }\n        if (stats.ctime) {\n            stats.ctime = new Date(stats.ctime);\n        }\n        // ensure a non-undefined size (0 isn't great, though)\n        stats.size = stats.size || 0;\n        return stats;\n    }\n    /**\n     * Normalize a Path by making it compliant for the content manager\n     *\n     * @param path: the path relatively to the Emscripten drive\n     */\n    normalizePath(path) {\n        // Remove mountpoint prefix\n        if (path.startsWith(this._mountpoint)) {\n            path = path.slice(this._mountpoint.length);\n        }\n        // Add JupyterLab drive name\n        if (this._driveName) {\n            path = `${this._driveName}${DRIVE_SEPARATOR}${path}`;\n        }\n        return path;\n    }\n    _driveName;\n    _mountpoint;\n    FS;\n    ERRNO_CODES;\n}\n/**\n * An Emscripten-compatible synchronous Contents API using the service worker.\n */\nexport class ServiceWorkerContentsAPI extends ContentsAPI {\n    constructor(baseUrl, driveName, mountpoint, FS, ERRNO_CODES) {\n        super(driveName, mountpoint, FS, ERRNO_CODES);\n        this._baseUrl = baseUrl;\n    }\n    request(data) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', encodeURI(this.endpoint), false);\n        try {\n            xhr.send(JSON.stringify(data));\n        }\n        catch (e) {\n            console.error(e);\n        }\n        if (xhr.status >= 400) {\n            throw new this.FS.ErrnoError(this.ERRNO_CODES['EINVAL']);\n        }\n        return JSON.parse(xhr.responseText);\n    }\n    /**\n     * Get the api/drive endpoint\n     */\n    get endpoint() {\n        return `${this._baseUrl}api/drive`;\n    }\n    _baseUrl;\n}\nexport class DriveFS {\n    FS;\n    API;\n    PATH;\n    ERRNO_CODES;\n    driveName;\n    constructor(options) {\n        this.FS = options.FS;\n        this.PATH = options.PATH;\n        this.ERRNO_CODES = options.ERRNO_CODES;\n        this.API = this.createAPI(options);\n        this.driveName = options.driveName;\n        this.node_ops = new DriveFSEmscriptenNodeOps(this);\n        this.stream_ops = new DriveFSEmscriptenStreamOps(this);\n    }\n    node_ops;\n    stream_ops;\n    /**\n     * Create the ContentsAPI.\n     *\n     * This is supposed to be overwritten if needed.\n     */\n    createAPI(options) {\n        return new ServiceWorkerContentsAPI(options.baseUrl, options.driveName, options.mountpoint, options.FS, options.ERRNO_CODES);\n    }\n    mount(mount) {\n        return this.createNode(null, mount.mountpoint, DIR_MODE | 511, 0);\n    }\n    createNode(parent, name, mode, dev) {\n        const FS = this.FS;\n        if (!FS.isDir(mode) && !FS.isFile(mode)) {\n            throw new FS.ErrnoError(this.ERRNO_CODES['EINVAL']);\n        }\n        const node = FS.createNode(parent, name, mode, dev);\n        node.node_ops = this.node_ops;\n        node.stream_ops = this.stream_ops;\n        return node;\n    }\n    getMode(path) {\n        return this.API.getmode(path);\n    }\n    realPath(node) {\n        const parts = [];\n        let currentNode = node;\n        parts.push(currentNode.name);\n        while (currentNode.parent !== currentNode) {\n            currentNode = currentNode.parent;\n            parts.push(currentNode.name);\n        }\n        parts.reverse();\n        return this.PATH.join.apply(null, parts);\n    }\n}\n//# sourceMappingURL=drivefs.js.map","/*\n * Copyright (c) 2021-2023 Datalayer, Inc.\n *\n * MIT License\n */\nexport class PyodideRemoteKernel {\n    constructor() {\n        this._initialized = new Promise((resolve, reject) => {\n            this._initializer = { resolve, reject };\n        });\n    }\n    /**\n     * Accept the URLs from the host\n     **/\n    async initialize(options) {\n        this._options = options;\n        if (options.location.includes(':')) {\n            const parts = options.location.split(':');\n            this._driveName = parts[0];\n            this._localPath = parts[1];\n        }\n        else {\n            this._driveName = '';\n            this._localPath = options.location;\n        }\n        await this.initRuntime(options);\n        await this.initFilesystem(options);\n        await this.initPackageManager(options);\n        await this.initKernel(options);\n        await this.initGlobals(options);\n        this._initializer?.resolve();\n    }\n    async initRuntime(options) {\n        const { pyodideUrl, indexUrl } = options;\n        let loadPyodide;\n        // Always use dynamic import for module workers\n        // In module workers, importScripts exists but throws when called\n        // Dynamic import works for both .mjs and .js files in module workers\n        const pyodideModule = await import(\n        /* webpackIgnore: true */ /* @vite-ignore */ pyodideUrl);\n        // Pyodide may export loadPyodide directly, or set it on self (for non-ESM builds)\n        loadPyodide = pyodideModule.loadPyodide || self.loadPyodide;\n        if (typeof loadPyodide !== 'function') {\n            throw new Error(`Failed to load pyodide from ${pyodideUrl}. loadPyodide is not a function.`);\n        }\n        this._pyodide = await loadPyodide({\n            indexURL: indexUrl,\n            ...options.loadPyodideOptions,\n        });\n    }\n    async initPackageManager(options) {\n        if (!this._options) {\n            throw new Error('Uninitialized');\n        }\n        const { pipliteWheelUrl, disablePyPIFallback, pipliteUrls, loadPyodideOptions, } = this._options;\n        const preloaded = (loadPyodideOptions || {}).packages || [];\n        if (!preloaded.includes('micropip')) {\n            await this._pyodide.loadPackage(['micropip']);\n        }\n        if (!preloaded.includes('piplite')) {\n            await this._pyodide.runPythonAsync(`\n      import micropip\n      await micropip.install('${pipliteWheelUrl}', keep_going=True)\n    `);\n        }\n        // get piplite early enough to impact pyodide-kernel dependencies\n        await this._pyodide.runPythonAsync(`\n      import piplite.piplite\n      piplite.piplite._PIPLITE_DISABLE_PYPI = ${disablePyPIFallback ? 'True' : 'False'}\n      piplite.piplite._PIPLITE_URLS = ${JSON.stringify(pipliteUrls)}\n    `);\n    }\n    async initKernel(options) {\n        const preloaded = (options.loadPyodideOptions || {}).packages || [];\n        const toLoad = [\n            'ssl',\n            'sqlite3',\n            'ipykernel',\n            'comm',\n            'pyodide_kernel',\n            'ipython',\n        ];\n        const scriptLines = [];\n        // use piplite for packages that weren't pre-loaded\n        for (const pkgName of toLoad) {\n            if (!preloaded.includes(pkgName)) {\n                scriptLines.push(`await piplite.install('${pkgName}', keep_going=True)`);\n            }\n        }\n        // import the kernel\n        scriptLines.push('import pyodide_kernel');\n        // cd to the kernel location\n        if (options.mountDrive && this._localPath) {\n            scriptLines.push('import os', `os.chdir(\"${this._localPath}\")`);\n        }\n        // from this point forward, only use piplite (but not %pip)\n        await this._pyodide.runPythonAsync(scriptLines.join('\\n'));\n    }\n    async initGlobals(options) {\n        const { globals } = this._pyodide;\n        this._kernel = globals.get('pyodide_kernel').kernel_instance.copy();\n        this._stdout_stream = globals.get('pyodide_kernel').stdout_stream.copy();\n        this._stderr_stream = globals.get('pyodide_kernel').stderr_stream.copy();\n        this._interpreter = this._kernel.interpreter.copy();\n        this._interpreter.send_comm = this.sendComm.bind(this);\n    }\n    /**\n     * Setup custom Emscripten FileSystem\n     */\n    async initFilesystem(options) {\n        if (options.mountDrive) {\n            const mountpoint = '/drive';\n            const { FS, PATH, ERRNO_CODES } = this._pyodide;\n            const { baseUrl } = options;\n            const { DriveFS } = await import('../contents');\n            const driveFS = new DriveFS({\n                FS: FS,\n                PATH,\n                ERRNO_CODES,\n                baseUrl,\n                driveName: this._driveName,\n                mountpoint,\n            });\n            FS.mkdirTree(mountpoint);\n            FS.mount(driveFS, {}, mountpoint);\n            FS.chdir(mountpoint);\n            this._driveFS = driveFS;\n        }\n    }\n    /**\n     * Recursively convert a Map to a JavaScript object\n     * @param obj A Map, Array, or other  object to convert\n     */\n    mapToObject(obj) {\n        const out = obj instanceof Array ? [] : {};\n        obj.forEach((value, key) => {\n            out[key] =\n                value instanceof Map || value instanceof Array\n                    ? this.mapToObject(value)\n                    : value;\n        });\n        return out;\n    }\n    /**\n     * Format the response from the Pyodide evaluation.\n     *\n     * @param res The result object from the Pyodide evaluation\n     */\n    formatResult(res) {\n        if (!(res instanceof this._pyodide.ffi.PyProxy)) {\n            return res;\n        }\n        // TODO: this is a bit brittle\n        const m = res.toJs();\n        const results = this.mapToObject(m);\n        return results;\n    }\n    /**\n     * Register the callback function to send messages from the worker back to the main thread.\n     * @param callback the callback to register\n     */\n    registerCallback(callback) {\n        this._sendWorkerMessage = callback;\n    }\n    /**\n     * Makes sure pyodide is ready before continuing, and cache the parent message.\n     */\n    async setup(parent) {\n        await this._initialized;\n        this._kernel._parent_header = this._pyodide.toPy(parent);\n    }\n    /**\n     * Execute code with the interpreter.\n     *\n     * @param content The incoming message with the code to execute.\n     */\n    async execute(content, parent) {\n        await this.setup(parent);\n        const publishExecutionResult = (prompt_count, data, metadata) => {\n            const bundle = {\n                execution_count: prompt_count,\n                data: this.formatResult(data),\n                metadata: this.formatResult(metadata),\n            };\n            this._sendWorkerMessage({\n                parentHeader: this.formatResult(this._kernel._parent_header)['header'],\n                bundle,\n                type: 'execute_result',\n            });\n        };\n        const publishExecutionError = (ename, evalue, traceback) => {\n            const bundle = {\n                ename: ename,\n                evalue: evalue,\n                traceback: traceback,\n            };\n            this._sendWorkerMessage({\n                parentHeader: this.formatResult(this._kernel._parent_header)['header'],\n                bundle,\n                type: 'execute_error',\n            });\n        };\n        const clearOutputCallback = (wait) => {\n            const bundle = {\n                wait: this.formatResult(wait),\n            };\n            this._sendWorkerMessage({\n                parentHeader: this.formatResult(this._kernel._parent_header)['header'],\n                bundle,\n                type: 'clear_output',\n            });\n        };\n        const displayDataCallback = (data, metadata, transient) => {\n            const bundle = {\n                data: this.formatResult(data),\n                metadata: this.formatResult(metadata),\n                transient: this.formatResult(transient),\n            };\n            this._sendWorkerMessage({\n                parentHeader: this.formatResult(this._kernel._parent_header)['header'],\n                bundle,\n                type: 'display_data',\n            });\n        };\n        const updateDisplayDataCallback = (data, metadata, transient) => {\n            const bundle = {\n                data: this.formatResult(data),\n                metadata: this.formatResult(metadata),\n                transient: this.formatResult(transient),\n            };\n            this._sendWorkerMessage({\n                parentHeader: this.formatResult(this._kernel._parent_header)['header'],\n                bundle,\n                type: 'update_display_data',\n            });\n        };\n        const publishStreamCallback = (name, text) => {\n            const bundle = {\n                name: this.formatResult(name),\n                text: this.formatResult(text),\n            };\n            this._sendWorkerMessage({\n                parentHeader: this.formatResult(this._kernel._parent_header)['header'],\n                bundle,\n                type: 'stream',\n            });\n        };\n        this._stdout_stream.publish_stream_callback = publishStreamCallback;\n        this._stderr_stream.publish_stream_callback = publishStreamCallback;\n        this._interpreter.display_pub.clear_output_callback = clearOutputCallback;\n        this._interpreter.display_pub.display_data_callback = displayDataCallback;\n        this._interpreter.display_pub.update_display_data_callback =\n            updateDisplayDataCallback;\n        this._interpreter.displayhook.publish_execution_result =\n            publishExecutionResult;\n        this._interpreter.input = this.input.bind(this);\n        this._interpreter.getpass = this.getpass.bind(this);\n        const res = await this._kernel.run(content.code);\n        const results = this.formatResult(res);\n        if (results['status'] === 'error') {\n            publishExecutionError(results['ename'], results['evalue'], results['traceback']);\n        }\n        return results;\n    }\n    /**\n     * Complete the code submitted by a user.\n     *\n     * @param content The incoming message with the code to complete.\n     */\n    async complete(content, parent) {\n        await this.setup(parent);\n        const res = this._kernel.complete(content.code, content.cursor_pos);\n        const results = this.formatResult(res);\n        return results;\n    }\n    /**\n     * Inspect the code submitted by a user.\n     *\n     * @param content The incoming message with the code to inspect.\n     */\n    async inspect(content, parent) {\n        await this.setup(parent);\n        const res = this._kernel.inspect(content.code, content.cursor_pos, content.detail_level);\n        const results = this.formatResult(res);\n        return results;\n    }\n    /**\n     * Check code for completeness submitted by a user.\n     *\n     * @param content The incoming message with the code to check.\n     */\n    async isComplete(content, parent) {\n        await this.setup(parent);\n        const res = this._kernel.is_complete(content.code);\n        const results = this.formatResult(res);\n        return results;\n    }\n    /**\n     * Respond to the commInfoRequest.\n     *\n     * @param content The incoming message with the comm target name.\n     */\n    async commInfo(content, parent) {\n        await this.setup(parent);\n        const res = this._kernel.comm_info(content.target_name);\n        const results = this.formatResult(res);\n        return {\n            comms: results,\n            status: 'ok',\n        };\n    }\n    /**\n     * Respond to the commOpen.\n     *\n     * @param content The incoming message with the comm open.\n     */\n    async commOpen(content, parent) {\n        await this.setup(parent);\n        const res = this._kernel.comm_manager.comm_open(this._pyodide.toPy(null), this._pyodide.toPy(null), this._pyodide.toPy(content));\n        const results = this.formatResult(res);\n        return results;\n    }\n    /**\n     * Respond to the commMsg.\n     *\n     * @param content The incoming message with the comm msg.\n     */\n    async commMsg(content, parent) {\n        await this.setup(parent);\n        const res = this._kernel.comm_manager.comm_msg(this._pyodide.toPy(null), this._pyodide.toPy(null), this._pyodide.toPy(content));\n        const results = this.formatResult(res);\n        return results;\n    }\n    /**\n     * Respond to the commClose.\n     *\n     * @param content The incoming message with the comm close.\n     */\n    async commClose(content, parent) {\n        await this.setup(parent);\n        const res = this._kernel.comm_manager.comm_close(this._pyodide.toPy(null), this._pyodide.toPy(null), this._pyodide.toPy(content));\n        const results = this.formatResult(res);\n        return results;\n    }\n    /**\n     * Resolve the input request by getting back the reply from the main thread\n     *\n     * @param content The incoming message with the reply\n     */\n    async inputReply(content, parent) {\n        await this.setup(parent);\n        this._resolveInputReply(content);\n    }\n    /**\n     * Send a input request to the front-end.\n     *\n     * @param prompt the text to show at the prompt\n     * @param password Is the request for a password?\n     */\n    async sendInputRequest(prompt, password) {\n        const content = {\n            prompt,\n            password,\n        };\n        this._sendWorkerMessage({\n            type: 'input_request',\n            parentHeader: this.formatResult(this._kernel._parent_header)['header'],\n            content,\n        });\n    }\n    async getpass(prompt) {\n        prompt = typeof prompt === 'undefined' ? '' : prompt;\n        await this.sendInputRequest(prompt, true);\n        const replyPromise = new Promise(resolve => {\n            this._resolveInputReply = resolve;\n        });\n        const result = await replyPromise;\n        return result['value'];\n    }\n    async input(prompt) {\n        prompt = typeof prompt === 'undefined' ? '' : prompt;\n        await this.sendInputRequest(prompt, false);\n        const replyPromise = new Promise(resolve => {\n            this._resolveInputReply = resolve;\n        });\n        const result = await replyPromise;\n        return result['value'];\n    }\n    /**\n     * Send a comm message to the front-end.\n     *\n     * @param type The type of the comm message.\n     * @param content The content.\n     * @param metadata The metadata.\n     * @param ident The ident.\n     * @param buffers The binary buffers.\n     */\n    async sendComm(type, content, metadata, ident, buffers) {\n        this._sendWorkerMessage({\n            type: type,\n            content: this.formatResult(content),\n            metadata: this.formatResult(metadata),\n            ident: this.formatResult(ident),\n            buffers: this.formatResult(buffers),\n            parentHeader: this.formatResult(this._kernel._parent_header)['header'],\n        });\n    }\n    /**\n     * Initialization options.\n     */\n    _options = null;\n    /**\n     * A promise that resolves when all initiaization is complete.\n     */\n    _initialized;\n    _initializer = null;\n    _pyodide = null;\n    /** TODO: real typing */\n    _localPath = '';\n    _driveName = '';\n    _kernel;\n    _interpreter;\n    _stdout_stream;\n    _stderr_stream;\n    _resolveInputReply;\n    _driveFS = null;\n    _sendWorkerMessage = () => { };\n}\n//# sourceMappingURL=worker.js.map","/*\n * Copyright (c) 2021-2023 Datalayer, Inc.\n *\n * MIT License\n */\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * A WebWorker entrypoint that uses coincident to handle postMessage details\n */\nimport coincident from 'coincident';\nimport { ContentsAPI, DriveFS, } from '../contents';\nimport { PyodideRemoteKernel } from './worker';\nconst workerAPI = coincident(self);\n/**\n * An Emscripten-compatible synchronous Contents API using shared array buffers.\n */\nexport class SharedBufferContentsAPI extends ContentsAPI {\n    request(data) {\n        return workerAPI.processDriveRequest(data);\n    }\n}\n/**\n * A custom drive implementation which uses shared array buffers (via coincident) if available\n */\nclass PyodideDriveFS extends DriveFS {\n    createAPI(options) {\n        return new SharedBufferContentsAPI(options.driveName, options.mountpoint, options.FS, options.ERRNO_CODES);\n    }\n}\nexport class PyodideCoincidentKernel extends PyodideRemoteKernel {\n    /**\n     * Setup custom Emscripten FileSystem\n     */\n    async initFilesystem(options) {\n        if (options.mountDrive) {\n            const mountpoint = '/drive';\n            const { FS, PATH, ERRNO_CODES } = this._pyodide;\n            const { baseUrl } = options;\n            const driveFS = new PyodideDriveFS({\n                FS: FS,\n                PATH,\n                ERRNO_CODES,\n                baseUrl,\n                driveName: this._driveName,\n                mountpoint,\n            });\n            FS.mkdirTree(mountpoint);\n            FS.mount(driveFS, {}, mountpoint);\n            FS.chdir(mountpoint);\n            this._driveFS = driveFS;\n        }\n    }\n}\nconst worker = new PyodideCoincidentKernel();\nconst sendWorkerMessage = workerAPI.processWorkerMessage.bind(workerAPI);\nworker.registerCallback(sendWorkerMessage);\nworkerAPI.initialize = worker.initialize.bind(worker);\nworkerAPI.execute = worker.execute.bind(worker);\nworkerAPI.complete = worker.complete.bind(worker);\nworkerAPI.inspect = worker.inspect.bind(worker);\nworkerAPI.isComplete = worker.isComplete.bind(worker);\nworkerAPI.commInfo = worker.commInfo.bind(worker);\nworkerAPI.commOpen = worker.commOpen.bind(worker);\nworkerAPI.commMsg = worker.commMsg.bind(worker);\nworkerAPI.commClose = worker.commClose.bind(worker);\nworkerAPI.inputReply = worker.inputReply.bind(worker);\n//# sourceMappingURL=coincident.worker.js.map"],"names":["FUNCTION","CHANNEL","GET","HAS","SET","isArray","Array","SharedArrayBuffer","window","globalThis","notify","wait","waitAsync","Atomics","postPatched","buffer","value","Promise","onmessage","w","Worker","postMessage","_","ArrayBuffer","ids","WeakMap","resolvers","Map","prototype","listener","event","details","data","stopImmediatePropagation","id","sb","get","rest","set","this","addEventListener","call","resolve","then","buff","delete","i","length","as","Int32Array","Uint16Array","BYTES_PER_ELEMENT","I32_BYTES","UI16_BYTES","buffers","WeakSet","context","syncResult","fn","uid","coincident","self","parse","JSON","stringify","transform","interrupt","has","sendMessage","post","transfer","args","handler","delay","decoder","TextDecoder","waitFor","isAsync","waitInterrupt","seppuku","Proxy","action","startsWith","at","pop","map","deadlock","setTimeout","console","warn","clearTimeout","bytes","decode","slice","actions","callback","type","Error","size","results","async","error","result","serialized","ui16a","charCodeAt","add","instanceOfStream","nodeOrStream","encoder","TextEncoder","flagNeedsWrite","DriveFSEmscriptenStreamOps","fs","constructor","open","stream","path","realPath","node","FS","isFile","mode","file","API","close","flags","parsedFlags","parseInt","needsWrite","put","read","offset","position","Math","min","subarray","write","timestamp","Date","now","oldData","Uint8Array","llseek","whence","ErrnoError","ERRNO_CODES","EPERM","EINVAL","DriveFSEmscriptenNodeOps","getattr","ino","setattr","attr","key","Object","entries","lookup","parent","name","PATH","join2","ok","createNode","mknod","dev","rename","newDir","newName","oldNode","newDirNode","unlink","rmdir","readdir","symlink","oldPath","readlink","ContentsAPI","driveName","mountpoint","_driveName","_mountpoint","request","method","normalizePath","getmode","newPath","dirlist","push","response","serializedContent","content","format","encode","binString","atob","len","binary","byteLength","String","fromCharCode","btoa","stats","atime","mtime","ctime","ServiceWorkerContentsAPI","baseUrl","super","_baseUrl","xhr","XMLHttpRequest","encodeURI","endpoint","send","e","status","responseText","DriveFS","options","createAPI","node_ops","stream_ops","mount","DIR_MODE","isDir","getMode","parts","currentNode","reverse","join","apply","PyodideRemoteKernel","_initialized","reject","_initializer","initialize","_options","location","includes","split","_localPath","initRuntime","initFilesystem","initPackageManager","initKernel","initGlobals","pyodideUrl","indexUrl","loadPyodide","import","_pyodide","indexURL","loadPyodideOptions","pipliteWheelUrl","disablePyPIFallback","pipliteUrls","preloaded","packages","loadPackage","runPythonAsync","toLoad","scriptLines","pkgName","mountDrive","globals","_kernel","kernel_instance","copy","_stdout_stream","stdout_stream","_stderr_stream","stderr_stream","_interpreter","interpreter","send_comm","sendComm","bind","index","driveFS","mkdirTree","chdir","_driveFS","mapToObject","obj","out","forEach","formatResult","res","ffi","PyProxy","m","toJs","registerCallback","_sendWorkerMessage","setup","_parent_header","toPy","execute","publishExecutionError","ename","evalue","traceback","bundle","parentHeader","publishStreamCallback","text","publish_stream_callback","display_pub","clear_output_callback","display_data_callback","metadata","transient","update_display_data_callback","displayhook","publish_execution_result","prompt_count","execution_count","input","getpass","run","code","complete","cursor_pos","inspect","detail_level","isComplete","is_complete","commInfo","comm_info","target_name","comms","commOpen","comm_manager","comm_open","commMsg","comm_msg","commClose","comm_close","inputReply","_resolveInputReply","sendInputRequest","prompt","password","replyPromise","ident","workerAPI","SharedBufferContentsAPI","processDriveRequest","PyodideDriveFS","worker","sendWorkerMessage","processWorkerMessage"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}